#include "publisher.hpp"
#include "consumer.hpp"
#include "s3service.pb.h"
#include "clientsocket.hpp"

#include <iostream>
#include <thread>
#include <cstddef>
#include <experimental/filesystem>
#include <bits/stdc++.h>
#include <vector>

#include <sys/stat.h>
#include <boost/filesystem.hpp>
#include <bits/stdc++.h>
#include <iostream>
#include <cstdint>
#include <boost/filesystem.hpp>

#include <unistd.h>
#include <stdio.h>

#include <string>
#include <termios.h>
#include <typeinfo>
#include <ctype.h>

#include <stdio.h>
#include <sys/types.h>
#include <dirent.h>

#include <sstream>

#include "auto.hpp"


#include <fcntl.h>


#include <cstdlib>
#include <cstring>
#include <fstream>
#include <netdb.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <dirent.h>
#include<vector>
#include <sstream>
#include<signal.h>


#define AUTOMATION 0

#if AUTOMATION 
#define AUTOMATION_FEATURE_ENABLED
#endif

using namespace Pistache;
using namespace Pistache::Rest;


using namespace std;


std::string breakclient = "Ok";
std::string getRequestId()
{
	std::srand(std::time(nullptr));

	return "id" + std::to_string(std::rand());
}


int filecount(std::string path)
{
	DIR *dp;
  	int i = 0;
  	struct dirent *ep;     
  	dp = opendir (path.c_str());

  	if (dp != NULL)
  	{
    	while (ep = readdir (dp))
      	  i++;

    	(void) closedir (dp);
  	}
  else
    perror ("Couldn't open the directory");

  return i-2;
}

auto readFromFile(clientSocket& cs, const std::string& objectPath, s3service::s3object& objRequest)
{
	std::ifstream iF(objectPath, std::ios::in | std::ios::binary);

	if (!iF)
	{
		std::cout << "File not found!";
		return false;
	}

	iF.seekg(0, std::ios::end);
	size_t size = iF.tellg();
	iF.seekg(0, std::ios::beg);

	char* data = new char[size];

	iF.read(data, size);
        iF.close();
	auto ret = cs.writeSocket(data, size);

	if (ret != "")
	{
		std::cout << ret << std::endl;
		return false;
	}

	objRequest.set_len(size);

	

	return true;
}
 std::string splitFile(const std::string & inputFile, const std::string & outputPrefix, int chunkSize) {
  // Open the input file in binary mode
  
  	std::string current_path= get_current_dir_name();
	std::string full_path=current_path+"/multipartupload/" + inputFile + "/";
	boost::filesystem::create_directories(full_path);
  	std::ifstream input(inputFile, std::ios::binary);

  if (input.is_open()) {
    // Get the file size
    input.seekg(0, std::ios::end);
    std::streampos fileSize = input.tellg();
    input.seekg(0, std::ios::beg);

    // Calculate the number of chunks
    int numChunks = (fileSize + chunkSize - 1) / chunkSize;

    // Read and write each chunk
    for (int i = 0; i < numChunks; ++i) {
      // Create or overwrite the output file
      std::ofstream output(full_path + outputPrefix +std::to_string(i + 1) + ".txt", std::ios::binary);

      if (output.is_open()) {
        std::vector < char > buffer(chunkSize);

        // Read a chunk of data from the input file
        input.read(buffer.data(), chunkSize);

        // Write the chunk to the output file
        output.write(buffer.data(), input.gcount());

        output.close();
      } else {
        std::cout << "Failed to open output file: " << outputPrefix + std::to_string(i + 1) + ".txt" << std::endl;
      }
    }

    input.close();

    //std::cout << "File split successfully." << std::endl;
    return full_path;
  } 
  else 
  {
    std::cout << "Failed to open the input file." << std::endl;
    return "";
  }
}
void writeToFile(clientSocket csRead, const std::string& filename, int len)
{
	std::string current_path= get_current_dir_name();
	std::string full_path=current_path+"/download/";
	boost::filesystem::create_directories(full_path);
	size_t extension_index = filename.find_last_of(".");
	string extension;
	if (extension_index != string::npos)
	{
		extension = filename.substr(extension_index);
	}
	std::ostringstream oss;
	oss << filename.substr(0, extension_index);
	string new_filename = oss.str();
	int i=0;
	string file = new_filename;
	new_filename += extension;
	while(true)
	{
		DIR *dir;
		struct dirent *ent;
		if ((dir = opendir(full_path.c_str())) != NULL)
		{
			int flag=0;
			while ((ent = readdir(dir)) != NULL)
			{
				string name(ent->d_name);
				if (name.find(new_filename) == 0)
				{
					i++;
					new_filename = file + "("+to_string(i)+")" + extension;
					flag=1;
				}
			}
			delete ent;
			if(flag == 0)
			{
				break;
			}
		}
		closedir(dir);
		}
	full_path=current_path+"/download/"+new_filename;
	std::ofstream oF(full_path.c_str(), std::ios::out | std::ios::binary);
	std::vector<char> data;

	auto ret = csRead.readSocket(data, len);

	if (ret != "")
	{
		std::cout << ret << std::endl;
	}

    oF.write(&data[0], len);
    oF.close();
}

std::string getObjectName(const std::string& path)
{
	std::experimental::filesystem::path p(path);

	return p.filename().string();
}

void createAndPublishRequestPacket(publisher* pub)
{
	clientSocket cs("127.0.0.1", 8081);
	cs.createAndConnect();
	int sockFd = cs.get_sockfd();

	while (true)
	{
		s3service::serviceRequestResponse request,response;

		std::cout << "Which action you wanna take?:" << std::endl;
		std::cout << "1. Account" << std::endl;
		std::cout << "2. User" << std::endl;
		std::cout << "3. AccessKey" << std::endl;
		std::cout << "4. Bucket" << std::endl;
		std::cout << "5. Object" << std::endl;
		//std::cout << std::endl;
		//auto entityType = response.entitytype();
		//std::cout << entityType << std::endl;
		
		std::string choice;
		std::cin >> choice;

		if (choice == "1")
		{
			request.set_entitytype(s3service::serviceRequestResponse::ACCOUNT);
			int flag = 0;
			auto accountRequest  = request.add_account();
			while(true)
			{
				std::cout << "Which action?:" << std::endl;
				std::cout << "1. Create Account" << std::endl;
				std::cout << "2. Delete Account" << std::endl;
				std::cout << "3. Go back" << std::endl;
				std::cin >> choice;

				if (choice == "1")
				{
					accountRequest->set_accop(s3service::s3account::CREATE_ACCOUNT);
					break;
				}
				else if(choice == "2")
				{
					accountRequest->set_accop(s3service::s3account::DELETE_ACCOUNT);
					break;
				}
				else if(choice == "3")
				{
					flag = 1;
					break;
				}
				else 
				{
					std::cout << "Enter the valid option from 1 or 2" << std::endl;
					continue;
				}
			}
			
			if(flag == 1)
			{
				continue;
			}
				
			std::string accountName, password;
			while(true){
				std::cout << "Enter account name: ";
				char name;
				int coun=0;
				name = getc(stdin);
				if(name != '\n')
					accountName+=name;
					int i=0;
					
				do{
					name = getc(stdin);
					if(name == '\n' && coun==0)
						cout << "You have entered new line, Please Enter the valid account name" << endl;
					else if(name != '\n')
					{
						accountName+=name;
						coun=1;
					}

				}while(name!='\n');
				if(coun)
					break;
        		
        		}
			accountRequest->set_accountname(accountName);
			while(true){
				std::cout << "Enter password: ";
				char pwd;
				int cou=0;
			        pwd=getc(stdin);
			        if(pwd!='\n')
					password+=pwd;
				
				do{
					pwd=getc(stdin);
					if(pwd!='\n')
					{
						password+=pwd;
						cou=1;
					}
					if(pwd == '\n' && cou==0)
						cout << "You have entered new line, Please Enter the valid account password" << endl;

				}while(pwd!='\n');
				if(cou)
					break;
        		
        		}
			accountRequest->set_password(password);

			if (choice == "1")
			{
				accountRequest->set_accop(s3service::s3account::CREATE_ACCOUNT);
			}
			else if(choice == "2")
			{
				accountRequest->set_accop(s3service::s3account::DELETE_ACCOUNT);
			}
			else 
			{
			}
		}
		else if (choice == "2")
		{
			request.set_entitytype(s3service::serviceRequestResponse::USER);
			int flag = 0;
			auto userRequest  = request.add_user();
			while(true)
			{
				std::cout << "Which action?:" << std::endl;
				std::cout << "1. Create User" << std::endl;
				std::cout << "2. Update User" << std::endl;
				std::cout << "3. Delete User" << std::endl;
				std::cout << "4. Go back" << std::endl;

				std::cin >> choice;
				if (choice == "1")
				{
					userRequest->set_userop(s3service::s3user::CREATE_USER);
					break;
				}
				else if (choice == "2")
				{
					
					std::string newName;
        			while(true){
					std::cout << "Enter New username: ";
					char nameU;
					int cou=0;
					nameU=getc(stdin);
					if(nameU!='\n')
						newName+=nameU;
					
					do{
						nameU=getc(stdin);
						if(nameU!='\n')
						{
							newName+=nameU;
							cou=1;
						}
						if(nameU == '\n' && cou==0)
							cout << "You have entered new line, Please Enter the valid New username" << endl;

				}while(nameU!='\n');
				if(cou)
					break;
        		
        		}

					userRequest->set_newusername(newName);

					userRequest->set_userop(s3service::s3user::UPDATE_USER);
					break;
				}
				else if(choice == "3")
				{
					userRequest->set_userop(s3service::s3user::DELETE_USER);
					break;
				}
				else if(choice == "4")
				{
					flag = 1;
					break;
				}
				else 
				{
					std::cout << "Enter the valid option from 1 to 3" << std::endl;
					continue;
				}
			}
			if(flag == 1)
			{
				continue;
			}
			std::string accessKey, secretKey;

			std::cout << "Enter Anthorization keys: " << std::endl;
				while(true){
					std::cout << "AccessKey: ";
					char accKey;
					int cou=0;
					accKey=getc(stdin);
					if(accKey!='\n')
						accessKey+=accKey;
					
					do{
						accKey=getc(stdin);
						if(accKey!='\n')
						{
							accessKey+=accKey;
							cou=1;
						}
						if(accKey == '\n' && cou==0)
							cout << "You have entered new line, Please Enter the valid AccessKey" << endl;

				}while(accKey!='\n');
				if(cou)
					break;
        		
        		}
        		while(true){
					std::cout << "SecretKey: ";
					char secKey;
					int cou=0;
					secKey=getc(stdin);
					if(secKey!='\n')
						secretKey+=secKey;
					
					do{
						secKey=getc(stdin);
						if(secKey!='\n')
						{
							secretKey+=secKey;
							cou=1;
						}
						if(secKey == '\n' && cou==0)
							cout << "You have entered new line, Please Enter the valid SecretKey" << endl;

				}while(secKey!='\n');
				if(cou)
					break;
        		
        		}

			auto auth = userRequest->add_auth();

			auth->set_accesskey(accessKey);
			auth->set_secretkey(secretKey);

			

			std::string userName;
       		while(true){
					std::cout << "Enter userName: ";
					char Uname1;
					int cou=0;
					Uname1=getc(stdin);
					if(Uname1!='\n')
						userName+=Uname1;
					
					do{
						Uname1=getc(stdin);
						if(Uname1!='\n')
						{
							userName+=Uname1;
							cou=1;
						}
						if(Uname1 == '\n' && cou==0)
							cout << "You have entered new line, Please Enter the valid userName" << endl;

				}while(Uname1!='\n');
				if(cou)
					break;
        		
        		}

			userRequest->set_username(userName);


		}
		else if (choice == "3")
		{
			request.set_entitytype(s3service::serviceRequestResponse::ACCESSKEY);
			int flag = 0;
			auto keyRequest  = request.add_accesskey();
			std::string accessKey,secretKey;
			while(true)
			{
				std::cout << "Which action?:" << std::endl;
				std::cout << "1. Create Key" << std::endl;
				std::cout << "2. Delete Key" << std::endl;
				std::cout << "3. Change Status" << std::endl;
				std::cout << "4. Get Last Used Time" << std::endl;
				std::cout << "5. Go back" << std::endl;
				std::cin >> choice;
				if (choice == "1")
				{
					keyRequest->set_accessop(s3service::s3accesskey::CREATE_KEY);
					break;
				}
				else if (choice == "2")
				{
					
				while(true){
					std::cout << "Enter accessKeyId: ";
					char accKey;
					int cou=0;
					accKey=getc(stdin);
					if(accKey!='\n')
						accessKey+=accKey;
					
					do{
						accKey=getc(stdin);
						if(accKey!='\n')
						{
							accessKey+=accKey;
							cou=1;
						}
						if(accKey == '\n' && cou==0)
							cout << "You have entered new line, Please Enter the valid accessKeyId" << endl;

				}while(accKey!='\n');
				if(cou)
					break;
        		
        		}

					keyRequest->set_accesskeyid(accessKey);

					keyRequest->set_accessop(s3service::s3accesskey::DELETE_KEY);
					break;
			}
				else if (choice == "3")
				{

				while(true){
					std::cout << "Enter accessKeyId ";
					char accKey;
					int cou=0;
					accKey=getc(stdin);
					if(accKey!='\n')
						accessKey+=accKey;
					
					do{
						accKey=getc(stdin);
						if(accKey!='\n')
						{
							accessKey+=accKey;
							cou=1;
						}
						if(accKey == '\n' && cou==0)
							cout << "You have entered new line, Please Enter the valid accessKeyId" << endl;

				}while(accKey!='\n');
				if(cou)
					break;
        		
        		}
					keyRequest->set_accesskeyid(accessKey);

					

					std::string status;
					while(true){
					std::cout << "Enter new status:(Active, Inactive) ";
					char sta;
					int cou=0;
					sta=getc(stdin);
					if(sta!='\n')
						status+=sta;
					
					do{
						sta=getc(stdin);
						if(sta!='\n')
						{
							status+=sta;
							cou=1;
						}
						if(sta == '\n' && cou==0)
							cout << "You have entered new line, Please Enter the valid statusd" << endl;

				}while(sta!='\n');
				if(cou)
					break;
        		
        		}		
					keyRequest->set_status(status);

					keyRequest->set_accessop(s3service::s3accesskey::CHANGE_KEY_STATUS);
					break;
				}
				else if(choice == "4")
				{
				while(true){
					std::cout << "Enter accessKeyId ";
					char accKey;
					int cou=0;
					accKey=getc(stdin);
					if(accKey!='\n')
						accessKey+=accKey;
					
					do{
						accKey=getc(stdin);
						if(accKey!='\n')
						{
							accessKey+=accKey;
							cou=1;
						}
						if(accKey == '\n' && cou==0)
							cout << "You have entered new line, Please Enter the valid accessKeyId" << endl;

				}while(accKey!='\n');
				if(cou)
					break;
        		
        		}


				        keyRequest->set_accesskeyid(accessKey);

					keyRequest->set_accessop(s3service::s3accesskey::LAST_USED_TIME);
					break;
				}
				else if(choice == "5")
				{
					flag=1;
					break;
				}
				else 
				{
					std::cout << "Enter the valid option from 1 to 4" << std::endl;
					continue;
				}
			}
			if(flag ==1)
			{
				continue;
			}

			

			std::cout << "Enter Anthorization keys: " << std::endl;
			
			if(choice == "1"){
			while(true){
					std::cout << "Enter accessKeyId ";
					char accKey;
					int cou=0;
					accKey=getc(stdin);
					if(accKey!='\n')
						accessKey+=accKey;
					
					do{
						accKey=getc(stdin);
						if(accKey!='\n')
						{
							accessKey+=accKey;
							cou=1;
						}
						if(accKey == '\n' && cou==0)
							cout << "You have entered new line, Please Enter the valid accessKeyId" << endl;

				}while(accKey!='\n');
				if(cou)
					break;
        		
        		}
        		}
        		while(true){
					std::cout << "SecretKey: ";
					char secKey;
					int cou=0;
					secKey=getc(stdin);
					if(secKey!='\n')
						secretKey+=secKey;
					
					do{
						secKey=getc(stdin);
						if(secKey!='\n')
						{
							secretKey+=secKey;
							cou=1;
						}
						if(secKey == '\n' && cou==0)
							cout << "You have entered new line, Please Enter the valid SecretKey" << endl;

				}while(secKey!='\n');
				if(cou)
					break;
        		
        		}
			auto auth = keyRequest->add_auth();
			auth->set_accesskey(accessKey);
			auth->set_secretkey(secretKey);

			

			std::string userName;
        		while(true){
					std::cout << "Enter userName: ";
					char uname;
					int cou=0;
					uname=getc(stdin);
					if(uname!='\n')
						userName+=uname;
					
					do{
						uname=getc(stdin);
						if(uname!='\n')
						{
							userName+=uname;
							cou=1;
						}
						if(uname == '\n' && cou==0)
							cout << "You have entered new line, Please Enter the valid userName" << endl;

				}while(uname!='\n');
				if(cou)
					break;
        		
        		}
			keyRequest->set_username(userName);
		}
		else if (choice == "4")
		{
			request.set_entitytype(s3service::serviceRequestResponse::BUCKET);

			auto bucketRequest  = request.add_bucket();
			int flag = 0;
			while(true)
			{
				std::cout << "Which action?:" << std::endl;
				std::cout << "1. Create Bucket" << std::endl;
				std::cout << "2. Delete Bucket" << std::endl;
				std::cout << "3. Put Bucket Version" << std::endl;
				std::cout << "4. Get Bucket Version" << std::endl;
				std::cout << "5. List Objects of Bucket" << std::endl;  
				std::cout << "6. List Object Versions of Bucket" << std::endl; 
				std::cout << "7. Add Lifecyle Rule for the bucket" << std::endl;
				std::cout << "8. Storage Quota" << std::endl;
				std::cout << "9. Storage Lens" << std::endl;
				std::cout << "10. Go back" << std::endl;  
				/*std::cout << "3. Put Bucket Tag" << std::endl;
				std::cout << "4. Get Bucket Tag" << std::endl;
				std::cout << "5. Put Bucket Version" << std::endl;*/
				std::cin >> choice;
				
				if (choice == "1")
				{
					bucketRequest->set_buckop(s3service::s3bucket::CREATE_BUCKET);
					break;
				}
				else if (choice == "2")
				{
					bucketRequest->set_buckop(s3service::s3bucket::DELETE_BUCKET);
					break;
				}
				else if(choice== "3")
				{
					bucketRequest->set_buckop(s3service::s3bucket::PUT_BUCKET_VERSION);
					break;
				}
				/*else if (choice == 3)
				{
					std::string key, value;

					std::cout << "Enter tag";

					std::cin >> key;
					std::cin >> value;


					auto tag = bucketRequest->add_tag();

					tag->set_key(key);
					tag->set_value(value);

					bucketRequest->set_buckop(s3service::s3bucket::PUT_BUCKET_TAG);
				}*/
				else if(choice== "4")
				{
					bucketRequest->set_buckop(s3service::s3bucket::GET_BUCKET_VERSION);
					break;
				}
				else if(choice== "5")
				{
					bucketRequest->set_buckop(s3service::s3bucket::LIST_OBJECT);
					break;
				}
				else if(choice== "6")
				{
					bucketRequest->set_buckop(s3service::s3bucket::LIST_OBJECT_VERSIONS);
					break;
				}
				else if(choice == "7")
				{
					
					//while(1)
					//{
						std::string expiry_date;
						cout << "Set expiry limit: ";
						cin >> expiry_date;
						//if( expiry_date > "0" && expiry_date <= "10")
						//{
							bucketRequest->set_expiry_date(expiry_date);
							//break;
						//}
						//else
						//{
							//std::cout<<"expiry_date must greater than 0 and less then 10"<< std::endl;
						//}
					
					//}
					
					bucketRequest->set_buckop(s3service::s3bucket::SET_LIFECYCLE_RULE);
					break;
				}
				else if(choice == "8")
				{
					std::string memory_space;
					std::string choices;
					
					cout << "1. Set Memory sapce for bucket in KB" << endl;
					cout << "2. Set Memory sapce for bucket in MB" << endl;
					cout << "3. Set Memory sapce for bucket in GB" << endl;
					cout << "Enter the option: ";
					cin >> choices ;
					//cout << endl;
					cout << "Enter Memory sapce: ";
					cin >> memory_space;
					std::string memory;
					//cout << endl; 
					if(choices == "1")
					{
						stringstream m;
						m << memory_space;
						double x = 0;
						m >> x;
						memory = to_string(x * 1000);	
					}
					else if(choices == "2")
					{
						stringstream m;
						m << memory_space;
						double x = 0;
						m >> x;
						memory = to_string(x * 1000000);
					}
					else if (choices =="3")
					{
						stringstream m;
						m << memory_space;
						double x = 0;
						m >> x;
						memory = to_string(x * 1000000000);
						cout << memory << endl;
					}
					bucketRequest->set_storagequota(memory);
					//cout << bucketRequest->storagequota() << endl;
					bucketRequest->set_buckop(s3service::s3bucket::SET_STORAGE_QUOTA);
					break;
				}
				else if(choice == "9")
				{
					bucketRequest->set_buckop(s3service::s3bucket::GET_STORAGE_LENS);
					break;
				}		
				else if(choice == "10")
				{
					flag = 1;
					break;
				}
				/*else if(choice==4)
				{
					bucketRequest->set_buckop(s3service::s3bucket::GET_BUCKET_TAG);
				}*/
				else
				{
					std::cout << "Enter valid option from 1 to 6 " << std::endl;
					continue;
				}
			
			}
			if(flag == 1)
				continue;
			std::string accessKey, secretKey;

			std::cout << "Enter Anthorization keys: " << std::endl;

				
				
				
			while(true){
					std::cout << "AccessKey: ";
					char accKey;
					int cou=0;
					accKey=getc(stdin);
					if(accKey!='\n')
						accessKey+=accKey;
					
					do{
						accKey=getc(stdin);
						if(accKey!='\n')
						{
							accessKey+=accKey;
							cou=1;
						}
						if(accKey == '\n' && cou==0)
							cout << "You have entered new line, Please Enter the valid AccessKey" << endl;

				}while(accKey!='\n');
				if(cou)
					break;
        		
        		}

        		while(true){
					std::cout << "SecretKey: ";
					char secKey;
					int cou=0;
					secKey=getc(stdin);
					if(secKey!='\n')
						secretKey+=secKey;
					
					do{
						secKey=getc(stdin);
						if(secKey!='\n')
						{
							secretKey+=secKey;
							cou=1;
						}
						if(secKey == '\n' && cou==0)
							cout << "You have entered new line, Please Enter the valid SecretKey" << endl;

				}while(secKey!='\n');
				if(cou)
					break;
        		
        		}

			auto auth = bucketRequest->add_auth();

			auth->set_accesskey(accessKey);
			auth->set_secretkey(secretKey);

			std::string bucketName;
			
			while(true){
					std::cout << "Enter bucket name: ";
					char buck_name;
					int cou=0;
					buck_name=getc(stdin);
					if(buck_name!='\n')
						bucketName+=buck_name;
					
					do{
						buck_name=getc(stdin);
						if(buck_name!='\n')
						{
							bucketName+=buck_name;
							cou=1;
						}
						if(buck_name == '\n' && cou==0)
							cout << "You have entered new line, Please Enter the valid bucket name" << endl;

				}while(buck_name!='\n');
				if(cou)
					break;
        		
        		}
			bucketRequest->set_bucketname(bucketName);


		}
		else if (choice == "5")
		{	
			request.set_entitytype(s3service::serviceRequestResponse::OBJECT);
			int flag = 0;
			auto objectRequest  = request.add_object();
			while(true)
			{
				std::cout << "Which action?:" << std::endl;
				std::cout << "1. Put Object" << std::endl;
				std::cout << "2. Delete Object" << std::endl;
				std::cout << "3. Get Object"  << std::endl;
				std::cout << "4. Get object by version" << std::endl;
				std::cout << "5. List Delete Marker Object" << std::endl;
				std::cout << "6. Get Delete Marker Object" << std::endl;
				std::cout << "7. Multi Part upload" << std::endl;
				std::cout << "8. INIT_MULTIPART_OBJECT"  << std::endl;
				std::cout << "9. PUT_MULTIPART_OBJECT"  << std::endl;
				std::cout << "10. COMPLETE_MULTIPART_OBJECT"  << std::endl;
				std::cout << "11. ABORT_MULTIPART_OBJECT"  << std::endl;
				std::cout << "12. LIST_MULTIPART_OBJECT"  << std::endl;
				std::cout << "13. Go back" << std::endl;
				std::cin >> choice;
				std::string objectName;
				if (choice == "1")
			       {
			       	std::string objectPath1;
			       	
			       	
			       				
			while(true){
					std::cout << "Enter ObjectName: ";
					char Obj_name;
					int cou=0;
					int flag1=0;
					Obj_name=getc(stdin);
					if(Obj_name!='\n')
						objectPath1+=Obj_name;
					
					do{
						Obj_name=getc(stdin);
						if(Obj_name!='\n')
						{
							objectPath1+=Obj_name;
							cou=1;
						}
						if(Obj_name == '\n' && cou==0)
							cout << "You have entered new line, Please Enter the valid ObjectName" << endl;

				}while(Obj_name!='\n');
				
				auto ret = readFromFile(cs, objectPath1, *objectRequest);
				
				if (ret == false)
				{
					std::cout << "readFromFile failed" << std::endl;
					objectPath1="";
					continue;
				}
				
				else if(cou)
					break;
					

        		
        		}

					//auto ret = readFromFile(cs, objectPath1, *objectRequest);

					//if (ret == false)
					//{
						//std::cout << "readFromFile failed" << std::endl;
						//break;
					//}

					objectRequest->set_objectop(s3service::s3object::PUT_OBJECT);
					objectName = getObjectName(objectPath1);
					objectRequest->set_objectname(objectName);
					break;
			     	}
				else if (choice == "2")
				{
					objectRequest->set_objectop(s3service::s3object::DELETE_OBJECT);
					break;
				}
				else if (choice == "3")
				{
					objectRequest->set_objectop(s3service::s3object::GET_OBJECT);
					break;
					
				}
		else if(choice == "4")
		{
			std::string versionId1;
			while(true)
			{
				std::cout << "Enter Object Version: ";
				char versionid;
				int cou=0;
				versionid = getc(stdin);
				if(versionid != '\n')
					versionId1 += versionid;
					
				do{
					versionid = getc(stdin);
					if(versionid != '\n')
					{
						versionId1 += versionid;
						cou=1;
					}
					if(versionid == '\n' && cou==0)
						cout << "You have entered new line, Please Enter the valid Object Version" << endl;

				}while(versionid !='\n');
				if(cou)
					break;
        		
        		}
        		objectRequest->set_getobjectbyversionid(versionId1);
			objectRequest->set_objectop(s3service::s3object::GET_OBJECT_BY_VERSION);
			break;
		}
		else if(choice == "5")
		{
			objectRequest->set_objectop(s3service::s3object::LIST_DELETE_MARKER_OBJECT);
			break;
		}
		else if(choice == "6")
		{
			std::string versionId1;
			while(true)
			{
				std::cout << "Enter Object Delete MarkerId: ";
				char versionid;
				int cou=0;
				versionid = getc(stdin);

				if(versionid != '\n')
					versionId1 += versionid;
					
				do{
					versionid = getc(stdin);
					if(versionid != '\n')
					{
						versionId1 += versionid;
						cou=1;
					}
					if(versionid == '\n' && cou==0)
						cout << "You have entered new line, Please Enter the valid Object Version" << endl;

				}while(versionid !='\n');
				if(cou)
					break;
        		
        		}
			objectRequest->set_markerid(versionId1);
			objectRequest->set_objectop(s3service::s3object::GET_DELETE_MARKER_OBJECT);
			break;
		}
		else if(choice == "7")
		{
			std:: cout << "Object extension must be .txt" << endl;
			std::cout << endl;
			std::cout << "Enter ObjectName: ";
			std::string objectPath1;
			char Obj_name;
			int cou=0;
			int flag1=0;
			Obj_name=getc(stdin);
			if(Obj_name!='\n')
			objectPath1+=Obj_name;
					
			do{
				Obj_name=getc(stdin);
				if(Obj_name!='\n')
				{
					objectPath1+=Obj_name;
					cou=1;
				}
				if(Obj_name == '\n' && cou==0)
				cout << "You have entered new line, Please Enter the valid ObjectName" << endl;

			}while(Obj_name!='\n');
			size_t extension_index = objectPath1.find_last_of(".");
			string extension;
			if (extension_index != string::npos)
			{
				extension = objectPath1.substr(extension_index);
			}
			if(extension != ".txt")
			{
				cout << "filename must .txt" << endl;
				flag = 1;
				break;
			}
			if(extension == ".txt")
			{
				std::string outputPrefix = "part_";
				std::string path = splitFile(objectPath1,outputPrefix, 600); 
				//cout << path << endl;
				int filenumbers = filecount(path);
				//cout << filenumbers << endl;
				//cout << filenumbers << endl;
				for(int i=0; i<filenumbers; i++)
				{
					std::string objectpath = path + "part_" + std::to_string(i + 1) + ".txt";
					//cout << objectpath << endl;
					readFromFile(cs, objectpath,  *objectRequest);
				}
				int ret=remove(path.c_str());
				objectRequest->set_objectname(objectPath1);
				objectRequest->set_objectop(s3service::s3object::PUT_MULTIPART_OBJECT);
			}
			break;
			
		}
		
		else if(choice=="8")
		{
					std:: cout << "Object extension must be .txt" << endl;
					std::cout << endl;
					std::cout << "Enter ObjectName: ";
					std::string objectPath1;
					char Obj_name;
					int cou=0;
					int flag1=0;
					Obj_name=getc(stdin);
					if(Obj_name!='\n')
					objectPath1+=Obj_name;
					
					do{
						Obj_name=getc(stdin);
						if(Obj_name!='\n')
						{
							objectPath1+=Obj_name;
							cou=1;
						}
						if(Obj_name == '\n' && cou==0)
						cout << "You have entered new line, Please Enter the valid ObjectName" << endl;

					}while(Obj_name!='\n');
					size_t extension_index = objectPath1.find_last_of(".");
					string extension;
					if (extension_index != string::npos)
					{
						extension = objectPath1.substr(extension_index);
					}
					if(extension != ".txt")
					{
						cout << "filename must .txt" << endl;
						flag = 1;
						break;
					}
					if(extension == ".txt")
					{
						std::string outputPrefix = "part_";
						std::string path = splitFile(objectPath1,outputPrefix, 600); 
						int filenumbers = filecount(path);
						objectRequest->set_objectname(objectPath1);
					}
					
					
					objectRequest->set_objectop(s3service::s3object::INIT_MULTIPART_OBJECT);
					break;
			}
			
			else if(choice=="9")
			{
				std::string objname;
				cout << "Enter the object name: ";
				cin >> objname;
				
				std::string parts;
				cout << "Enter the object part: ";
				cin >> parts;
				
					std::string objectPath= "multipartupload/" + objname + "/" + parts;
					//objectPath = objname + "/" + parts;
					cout << objectPath << endl;
					auto ret = readFromFile(cs, objectPath, *objectRequest);
					if (ret == false)
					{
						std::cout << "readFromFile failed" << std::endl;
						continue;
					}
					std::string objpat = objname + "/" + parts;
					objectRequest->set_objectname(objpat);
					objectRequest->set_objectop(s3service::s3object::PUT_MULTIPART);
					break;
					
			}
			else if(choice=="10")
			{
				std::string current_path = get_current_dir_name();
				std::string objname;
				cout << "Enter the object name: ";
				cin >> objname;
				objectRequest->set_objectname(objname);
				std::string path = current_path + "/multipartupload/" + objname + "/" ;
				
				int filenumbers = filecount(path);
				objectRequest->set_filecount(to_string(filenumbers));
				/*boost::system::error_code ec;
				boost::filesystem::remove_all(path.c_str(), ec);
				if (ec)
				{
					std::cout << "Folder Not Deleted" << std::endl;
					
				}*/
				//int ret = remove(path.c_str());
				objectRequest->set_objectop(s3service::s3object::COMPLETE_MULTIPART_OBJECT);
				break;
				
			}

		else if (choice=="11")
		{
			objectRequest->set_objectop(s3service::s3object::ABORT_MULTIPART_OBJECT);
			break;

		}
			
			
		else if (choice=="12")
		{
			objectRequest->set_objectop(s3service::s3object::LIST_MULTIPART_OBJECT);
			break;
		}
		else if(choice == "13")
		{	
			 flag = 1;
			 break;
		}
			      else 
			      {
					std::cout << "Invalid option Please enter from 1 to 3" << std::endl;
					continue;
	     		      }

		}
	
		if(flag==1)
		{
			continue;
		}
			

			std::string accessKey, secretKey;

			std::cout << "Enter Authorization keys: " << std::endl;
			while(true){
					std::cout << "AccessKey: ";
					char accKey;
					int cou=0;
					accKey=getc(stdin);
					if(accKey!='\n')
						accessKey+=accKey;
					
					do{
						accKey=getc(stdin);
						if(accKey!='\n')
						{
							accessKey+=accKey;
							cou=1;
						}
						if(accKey == '\n' && cou==0)
							cout << "You have entered new line, Please Enter the valid AccessKey" << endl;

				}while(accKey!='\n');
				if(cou)
					break;
        		
        		}
			
        		///
        		while(true){
					std::cout << "SecretKey: ";
					char secKey;
					int cou=0;
					secKey=getc(stdin);
					if(secKey!='\n')
						secretKey+=secKey;
					
					do{
						secKey=getc(stdin);
						if(secKey!='\n')
						{
							secretKey+=secKey;
							cou=1;
						}
						if(secKey == '\n' && cou==0)
							cout << "You have entered new line, Please Enter the valid SecretKey" << endl;

				}while(secKey!='\n');
				if(cou)
					break;
        		
        		}

			
			

			auto auth = objectRequest->add_auth();

			auth->set_accesskey(accessKey);
			auth->set_secretkey(secretKey);

			std::string bucketName, objectPath;
			
			while(true){
					std::cout << "Enter bucket name: ";
					char buck_name;
					int cou=0;
					buck_name=getc(stdin);
					if(buck_name!='\n')
						bucketName+=buck_name;
					
					do{
						buck_name=getc(stdin);
						if(buck_name!='\n')
						{
							bucketName+=buck_name;
							cou=1;
						}
						if(buck_name == '\n' && cou==0)
							cout << "You have entered new line, Please Enter the bucket name" << endl;

				}while(buck_name!='\n');
				if(cou)
					break;
        		
        		}
			objectRequest->set_bucketname(bucketName);
			//cout << objectRequest->objectop() << endl;
			if(choice!= "1" && choice !="4" && choice != "6" && choice != "7"  && choice != "9"  && choice != "10" && choice != "8")
			{
												
			while(true){
					std::cout << "Enter ObjectName: ";
					char Obj_name;
					int cou=0;
					Obj_name=getc(stdin);
					if(Obj_name!='\n')
						objectPath+=Obj_name;
					
					do{
						Obj_name=getc(stdin);
						if(Obj_name!='\n')
						{
							objectPath+=Obj_name;
							cou=1;
						}
						if(Obj_name == '\n' && cou==0)
							cout << "You have entered new line, Please Enter the valid Object name" << endl;

				}while(Obj_name!='\n');
				if(cou)
					break;
        		
        			}
				std::string objectName = getObjectName(objectPath);
				objectRequest->set_objectname(objectName);
				
			}
			
		}
	        else 
	        {
			std::cout << "Invalid option Please enter from 1 to 5" << std::endl;
			continue;
	        }
		auto requestId = getRequestId();

		std::cout << "Request Id: " << requestId << std::endl;
		request.set_requestid(requestId);

		auto serializedProto = request.SerializeAsString();
		
	    fd_set readSet;
	    FD_ZERO(&readSet);
	    FD_SET(sockFd, &readSet);

	    // Set timeout to 0 for non-blocking check
	    timeval timeout;
	    timeout.tv_sec = 0;
	    timeout.tv_usec = 0;
	    int result = select(sockFd+1, &readSet, nullptr, nullptr, &timeout);
	    //cout << "Result: " << result << endl;
	    if (result == -1) {
		 //Error occurred while checking socket
		 std::cerr << "Error in select(): " << strerror(errno) << std::endl;
	    } else if (result == 0) {
		// Socket is connected
		pub->publishMessage(serializedProto, "test");
		
	    } else {
	   	// Socket is connected
		std::cout << "Socket is not connected" << std::endl;
		breakclient = "no";
		close(sockFd);
		//cout << breakclient << endl;
		return;
	    }
		
	sleep(3);
		
	}
	//break;
}

void displayConsumedMessage(clientSocket& csRead, s3service::serviceRequestResponse response)
{
	auto entityType = response.entitytype();

	std::cout << "Request Id: " << response.requestid() << std::endl;
	//std::cout << entityType << std::endl;
	if (entityType == s3service::serviceRequestResponse::ACCOUNT)
	{
		for (int i = 0; i < response.account_size(); i++)
		{
			auto accountResponse = response.account(i);

			auto accountOp = accountResponse.accop();

			if (accountOp == s3service::s3account::CREATE_ACCOUNT)
			{
				if (accountResponse.errorinfo_size() == 0)
				{
					std::cout << "Account created successfully" << std::endl;
					std::cout << "AccountId: " << accountResponse.accountid() << std::endl;

					auto key = accountResponse.keys(0);

					std::cout << "AccessKeyId: " << key.accesskeyid() << std::endl;
					std::cout << "SecretKey: " << key.secretkey() << std::endl;
				}
				else
				{
					s3service::errorDetails error = accountResponse.errorinfo(0);

					auto errorCode = error.errorcode();

					std::cout << "Encountered an error while createAccount():" << std::endl;
					std::cout << "Error Type:" << error.errortype() << std::endl;
					std::cout << "Error Code: " << error.errorcode() << std::endl;
					std::cout << "Error Message: " << error.errormessage() << std::endl;
				}
			}
			else
			{
				if (accountResponse.errorinfo_size() == 0)
				{
					std::cout << "Account deleted successfully" << std::endl;
				}
				else
				{
					s3service::errorDetails error = accountResponse.errorinfo(0);

					auto errorCode = error.errorcode();

					std::cout << "Encountered an error while deleteAccount():" << std::endl;
					std::cout << "Error Type:" << error.errortype() << std::endl;
					std::cout << "Error Code: " << error.errorcode() << std::endl;
					std::cout << "Error Message: " << error.errormessage() << std::endl;
				}
			}
		}
	}
	else if (entityType == s3service::serviceRequestResponse::SERVER)
	{
		for (int i = 0; i < response.server_size(); i++)
		{
			auto serverResponse = response.server(i);
			auto serverOp = serverResponse.serverop();
			if(serverOp = s3service::S3server::Serverdown)
			{
				if(serverResponse.errorinfo_size() != 0)
				{
					s3service::errorDetails error = serverResponse.errorinfo(0);

					auto errorCode = error.errorcode();

					std::cout << "Encountered an error while createUser():" << std::endl;
					std::cout << "Error Type:" << error.errortype() << std::endl;
					std::cout << "Error Code: " << error.errorcode() << std::endl;
					std::cout << "Error Message: " << error.errormessage() << std::endl;
					break;
				}
			}
			
		} 
	}
	else if (entityType == s3service::serviceRequestResponse::USER)
	{
		for (int i = 0; i < response.user_size(); i++)
		{
			auto userResponse = response.user(i);

			auto userOp = userResponse.userop();

			if (userOp == s3service::s3user::CREATE_USER)
			{
				if (userResponse.errorinfo_size() == 0)
				{
					//userResponse.set_arn("1234");
					std::cout << "User created successfully" << std::endl;
					std::cout << "User Arn: " << userResponse.arn() << std::endl;
					std::cout << "User Id: " << userResponse.userid() << std::endl;
					std::cout << "Test Arn: " << userResponse.test() << std::endl;
					std::cout << "Create Date: " << userResponse.createdate() << std::endl;
				}
				else
				{
					s3service::errorDetails error = userResponse.errorinfo(0);

					auto errorCode = error.errorcode();

					std::cout << "Encountered an error while createUser():" << std::endl;
					std::cout << "Error Type:" << error.errortype() << std::endl;
					std::cout << "Error Code: " << error.errorcode() << std::endl;
					std::cout << "Error Message: " << error.errormessage() << std::endl;
				}
			}
			else if (userOp == s3service::s3user::DELETE_USER)
			{
				if (userResponse.errorinfo_size() == 0)
				{
					std::cout << "User deleted successfully" << std::endl;
				}
				else
				{
					s3service::errorDetails error = userResponse.errorinfo(0);

					auto errorCode = error.errorcode();

					std::cout << "Encountered an error deleteUser():"  << std::endl;
					std::cout << "Error Type:" << error.errortype() << std::endl;
					std::cout << "Error Code: " << error.errorcode() << std::endl;
					std::cout << "Error Message: " << error.errormessage() << std::endl;
				}
			}
			else
			{
				if (userResponse.errorinfo_size() == 0)
				{
					std::cout << "User updated successfully" << std::endl;
				}
				else
				{
					s3service::errorDetails error = userResponse.errorinfo(0);

					auto errorCode = error.errorcode();

					std::cout << "Encountered an error updateUser():" << std::endl;
					std::cout << "Error Type:" << error.errortype() << std::endl;
					std::cout << "Error Code: " << error.errorcode() << std::endl;
					std::cout << "Error Message: " << error.errormessage() << std::endl;
				}
			}
		}
	}
	else if (entityType == s3service::serviceRequestResponse::ACCESSKEY)
	{
		for (int i = 0; i < response.accesskey_size(); i++)
		{
			auto keyResponse = response.accesskey(i);

			auto keyOp = keyResponse.accessop();

			if (keyOp == s3service::s3accesskey::CREATE_KEY)
			{
				if (keyResponse.errorinfo_size() == 0)
				{
					std::cout << "Key created successfully" << std::endl;
					std::cout << "AccessKey: " << keyResponse.accesskeyid() << std::endl;
					std::cout << "SecretKey: " << keyResponse.secretkey() << std::endl;
					std::cout << "AccessKeySelector:" << keyResponse.accesskeyselector() << std::endl;
					std::cout << "CreationDate: " << keyResponse.createdate() << std::endl;
					std::cout << "Status: " << keyResponse.status() << std::endl;
				}
				else
				{
					s3service::errorDetails error = keyResponse.errorinfo(0);

					auto errorCode = error.errorcode();

					std::cout << "Encountered an error while createKey():"  << std::endl;
					std::cout << "Error Type:" << error.errortype() << std::endl;
					std::cout << "Error Code: " << error.errorcode() << std::endl;
					std::cout << "Error Message: " << error.errormessage() << std::endl;
				}
			}
			else if (keyOp == s3service::s3accesskey::DELETE_KEY)
			{
				if (keyResponse.errorinfo_size() == 0)
				{
					std::cout << "Key deleted successfully" << std::endl;
				}
				else
				{
					s3service::errorDetails error = keyResponse.errorinfo(0);

					auto errorCode = error.errorcode();

					std::cout << "Encountered an error deleteKey():" << std::endl;
					std::cout << "Error Type:" << error.errortype() << std::endl;
					std::cout << "Error Code: " << error.errorcode() << std::endl;
					std::cout << "Error Message: " << error.errormessage() << std::endl;
				}
			}
			else if (keyOp == s3service::s3accesskey::CHANGE_KEY_STATUS)
			{
				if (keyResponse.errorinfo_size() == 0)
				{
					std::cout << "Key status updated successfully" << std::endl;
				}
				else
				{
					s3service::errorDetails error = keyResponse.errorinfo(0);

					auto errorCode = error.errorcode();

					std::cout << "Encountered an error changeKeyStatus():" << std::endl;
					std::cout << "Error Type:" << error.errortype() << std::endl;
					std::cout << "Error Code: " << error.errorcode() << std::endl;
					std::cout << "Error Message: " << error.errormessage() << std::endl;
				}
			}
			else
			{
				if (keyResponse.errorinfo_size() == 0)
				{
					std::cout << "Last Used Time: " << keyResponse.lastuseddate() << std::endl;
					std::cout << "ServiceName: " << keyResponse.servicename() << std::endl;
				}
				else
				{
					s3service::errorDetails error = keyResponse.errorinfo(0);

					auto errorCode = error.errorcode();

					std::cout << "Encountered an error getLastUsedTime():" << std::endl;
					std::cout << "Error Type:" << error.errortype() << std::endl;
					std::cout << "Error Code: " << error.errorcode() << std::endl;
					std::cout << "Error Message: " << error.errormessage() << std::endl;
				}
			}
		}
	}
	else if (entityType == s3service::serviceRequestResponse::BUCKET)
	{
		for (int i = 0; i < response.bucket_size(); i++)
		{
			auto bucketResponse = response.bucket(i);

			auto bucketOp = bucketResponse.buckop();

			if (bucketOp == s3service::s3bucket::CREATE_BUCKET)
			{
				if (bucketResponse.errorinfo_size() == 0)
				{
					std::cout << "Bucket created successfully" << std::endl;
				}
				else
				{
					s3service::errorDetails error = bucketResponse.errorinfo(0);

					auto errorCode = error.errorcode();

					std::cout << "Encountered an error while createBucket():"  << std::endl;
					std::cout << "Error Code: " << error.errorcode() << std::endl;
					std::cout << "Error Message: " << error.errormessage() << std::endl;
				}
			}
			else if(bucketOp == s3service::s3bucket::SET_STORAGE_QUOTA)
			{
				if (bucketResponse.errorinfo_size() == 0)
				{
					std::cout << "Storage space is set for the bucket" << std::endl;
				}
				else
				{
					s3service::errorDetails error = bucketResponse.errorinfo(0);

					auto errorCode = error.errorcode();

					std::cout << "Encountered an error deleteBucket():" << std::endl;
					std::cout << "Error Type:" << error.errortype() << std::endl;
					std::cout << "Error Code: " << error.errorcode() << std::endl;
					std::cout << "Error Message: " << error.errormessage() << std::endl;
				}
			}
			else if(bucketOp == s3service::s3bucket::GET_STORAGE_LENS)
			{
				if (bucketResponse.errorinfo_size() == 0)
				{
					float count = 0;
					std::string str = bucketResponse.storagelens();
					std::string str1 = bucketResponse.storagelens();
					char* string1 = &str1[0];
					std::string word = "";
					int index=0;
   					for (auto x : str)
    					{
        					if (x == ' ')
        					{
            						std::cout << "list of objects with extension " <<  word << std::endl;
           						word = "";
           						
        					}
        					else {
            						word = word + x;
        					}
    					}
    					
    					for(int i=0; i<str1.length();i++)
    					{
    						if(isdigit(str1[i]))
   						{
   							char a = str1[i];
   							float converttonumber = stoi(&a);
   							count += converttonumber;
   						}
    					}
    					cout << endl;
   					//std::cout << "list of objects with extension " << word << std::endl;
   					for(int i=0; i < str1.length();i++)
   					{
   						if(!isdigit(str[i]) && str[i] != ' ' && str[i] !=':')
   						{
   							cout << str1[i];
   						}
   						if(isdigit(str1[i]))
   						{
   							cout << " files percentage is ";
   				
   							char a = str1[i];
   							float converttonumber = stoi(&a);
   						
   							float peroffiles = (converttonumber/count)*100;
   							printf("%.0f%%", peroffiles);
   							
   							//cout << "%2f" << peroffiles << endl;
   							cout << endl;
   						}
   					}	
   					
				}
				else
				{
					s3service::errorDetails error = bucketResponse.errorinfo(0);

					auto errorCode = error.errorcode();

					std::cout << "Encountered an error deleteBucket():" << std::endl;
					std::cout << "Error Type:" << error.errortype() << std::endl;
					std::cout << "Error Code: " << error.errorcode() << std::endl;
					std::cout << "Error Message: " << error.errormessage() << std::endl;
				}
			}
			else if (bucketOp == s3service::s3bucket::SET_LIFECYCLE_RULE)
			{
				if (bucketResponse.errorinfo_size() == 0)
				{
					std::cout << "Lifecyle rule is successfully set for the bucket" << std::endl;
				}
				else
				{
					s3service::errorDetails error = bucketResponse.errorinfo(0);

					auto errorCode = error.errorcode();

					std::cout << "Encountered an error deleteBucket():" << std::endl;
					std::cout << "Error Type:" << error.errortype() << std::endl;
					std::cout << "Error Code: " << error.errorcode() << std::endl;
					std::cout << "Error Message: " << error.errormessage() << std::endl;
				}
			}
			
			else if (bucketOp == s3service::s3bucket::DELETE_BUCKET)
			{
				if (bucketResponse.errorinfo_size() == 0)
				{
					std::cout << "Bucket deleted successfully" << std::endl;
				}
				else
				{
					s3service::errorDetails error = bucketResponse.errorinfo(0);

					auto errorCode = error.errorcode();

					std::cout << "Encountered an error deleteBucket():" << std::endl;
					std::cout << "Error Type:" << error.errortype() << std::endl;
					std::cout << "Error Code: " << error.errorcode() << std::endl;
					std::cout << "Error Message: " << error.errormessage() << std::endl;
				}
			}
			else if (bucketOp == s3service::s3bucket::PUT_BUCKET_TAG)
			{
				if (bucketResponse.errorinfo_size() == 0)
				{
					std::cout << "Bucket Tag updated successfully" << std::endl;
				}
				else
				{
					s3service::errorDetails error = bucketResponse.errorinfo(0);

					auto errorCode = error.errorcode();

					std::cout << "Encountered an error putBucketTag():" << std::endl;
					std::cout << "Error Type:" << error.errortype() << std::endl;
					std::cout << "Error Code: " << error.errorcode() << std::endl;
					std::cout << "Error Message: " << error.errormessage() << std::endl;
				}
			}
			else if(bucketOp == s3service::s3bucket::PUT_BUCKET_VERSION)
			{
				if (bucketResponse.errorinfo_size() == 0)
				{
				 	std::cout << "Version is " <<bucketResponse.version() << std::endl;
				}
				else
				{
					s3service::errorDetails error = bucketResponse.errorinfo(0);

					auto errorCode = error.errorcode();

					std::cout << "Encountered an error putBucketTag():" << std::endl;
					std::cout << "Error Type:" << error.errortype() << std::endl;

					std::cout << "Error Code: " << error.errorcode() << std::endl;
					std::cout << "Error Message: " << error.errormessage() << std::endl;
				}
			}
			
		        else if(bucketOp == s3service::s3bucket::GET_BUCKET_VERSION)
			{
				if (bucketResponse.errorinfo_size() == 0)
				{
				 	std::cout << "Version is " << bucketResponse.version() << std::endl;
				}
				else
				{
					s3service::errorDetails error = bucketResponse.errorinfo(0);

					auto errorCode = error.errorcode();

					std::cout << "Encountered an error putBucketTag():" << std::endl;
					std::cout << "Error Type:" << error.errortype() << std::endl;

					std::cout << "Error Code: " << error.errorcode() << std::endl;

					std::cout << "Error Message: " << error.errormessage() << std::endl;
				}
			}
			else if (bucketOp == s3service::s3bucket::LIST_OBJECT_VERSIONS)
			{
				if (bucketResponse.errorinfo_size() == 0)
				{
					std::cout << "List of Object: " << std::endl;
					std::cout << std::endl;
					std::string str=bucketResponse.list_object_versions();
					std::string word = "";
					std::vector<std::string> updateprefix;
					updateprefix.push_back("Object Name: ");
					updateprefix.push_back("Object Size: ");
					updateprefix.push_back("Version Status: ");
					updateprefix.push_back("Version ID: ");
					int index=0;
					int totalobject=0;
   					for (auto x : str)
    					{
        					if (x == ' ')
        					{
            						std::cout << updateprefix[index++] <<  word << std::endl;
           						word = "";
           						if(index%4==0)
           						{
           							totalobject++;
           							index=0;
           							std::cout << std::endl;
           							std::cout << std::endl;
           						}
        					}
        					else {
            						word = word + x;
        					}
    					}
   					std::cout << word << std::endl;
   					std::cout << "\n" << std::endl;
   					std::cout << "Total Object: " << totalobject << std::endl;
				}
				else
				{
					s3service::errorDetails error = bucketResponse.errorinfo(0);

					auto errorCode = error.errorcode();

					std::cout << "Encountered an error listObject():" << std::endl;
					std::cout << "Error Type:" << error.errortype() << std::endl;

					std::cout << "Error Code: " << error.errorcode() << std::endl;
					std::cout << "Error Message: " << error.errormessage() << std::endl;
				}
			}
			

			else if (bucketOp == s3service::s3bucket::LIST_OBJECT)
			{
				if (bucketResponse.errorinfo_size() == 0)
				{
					std::cout << "List of Object: " << std::endl;
					std::cout << std::endl;
					std::string str=bucketResponse.list_object();
					std::string word = "";
					int index=0;
   					for (auto x : str)
    					{
        					if (x == ' ')
        					{
            						std::cout <<  word << std::endl;
           						word = "";
        					}
        					else {
            						word = word + x;
        					}
    					}
   					std::cout << word << std::endl;
   					std::cout << std::endl;
				}
				else
				{
					s3service::errorDetails error = bucketResponse.errorinfo(0);

					auto errorCode = error.errorcode();

					std::cout << "Encountered an error listObject():" << std::endl;
					std::cout << "Error Type:" << error.errortype() << std::endl;

					std::cout << "Error Code: " << error.errorcode() << std::endl;
					std::cout << "Error Message: " << error.errormessage() << std::endl;
				}
			}
			else
			{
				if (bucketResponse.errorinfo_size() == 0)
				{
					std::cout << "Following are all the tags: " << std::endl;

					for (int i = 0; i < bucketResponse.tag_size(); i++)
					{
						std::cout << "Tag" << i+1 << ":" << std::endl;
						auto tag = bucketResponse.tag(i);

						std::cout << tag.key() << "->" << tag.value() << std::endl;
					}
				}
				else
				{
					s3service::errorDetails error = bucketResponse.errorinfo(0);

					auto errorCode = error.errorcode();

					std::cout << "Encountered an error getLastUsedTime():" << std::endl;
					std::cout << "Error Type:" << error.errortype() << std::endl;
					std::cout << "Error Code: " << error.errorcode() << std::endl;
					std::cout << "Error Message: " << error.errormessage() << std::endl;
				}
			}

		}
	}
	else if (entityType == s3service::serviceRequestResponse::OBJECT)
	{
		for (int i = 0; i < response.object_size(); i++)
		{
			auto objectResponse = response.object(i);

			auto objectOp = objectResponse.objectop();

			if (objectOp == s3service::s3object::PUT_OBJECT)
			{
				if (objectResponse.errorinfo_size() == 0)
				{
					std::cout << "Object created successfully" << std::endl;
				}
				else
				{
					s3service::errorDetails error = objectResponse.errorinfo(0);

					auto errorCode = error.errorcode();

					std::cout << "Encountered an error while createObject():"  << std::endl;
					std::cout << "Error Code: " << error.errorcode() << std::endl;
					std::cout << "Error Message: " << error.errormessage() << std::endl;
				}
			}
			else if (objectOp == s3service::s3object::INIT_MULTIPART_OBJECT)
			{
				if (objectResponse.errorinfo_size() == 0)
				{
					std::cout << "Object path set successfully" << std::endl;
				}
				else
				{
					s3service::errorDetails error = objectResponse.errorinfo(0);

					auto errorCode = error.errorcode();

					std::cout << "Encountered an error completeMultiPartUpload():" << std::endl;
					std::cout << "Error Type:" << error.errortype() << std::endl;
					std::cout << "Error Code: " << error.errorcode() << std::endl;
					std::cout << "Error Message: " << error.errormessage() << std::endl;
				}
			}
			
			else if(objectOp == s3service::s3object::LIST_MULTIPART_OBJECT)
			{
				if (objectResponse.errorinfo_size() == 0)
				{
					std::cout << "****List of multipart Object****" << std::endl;
					std::cout << std::endl;
					std::string str = objectResponse.filename();
					std::string word = "";
					int index=0;
   					for (auto x : str)
    					{
        					if (x == ' ')
        					{
            						std::cout <<  word << std::endl;
           						word = "";
        					}
        					else {
            						word = word + x;
        					}
    					}
   					std::cout << word << std::endl;
   					std::cout << std::endl;
				}
				else
				{
					s3service::errorDetails error = objectResponse.errorinfo(0);

					auto errorCode = error.errorcode();

					std::cout << "Encountered an error listMultiPartUpload():" << std::endl;
					std::cout << "Error Type:" << error.errortype() << std::endl;

					std::cout << "Error Code: " << error.errorcode() << std::endl;
				
				}
			}
			
			else if(objectOp == s3service::s3object::ABORT_MULTIPART_OBJECT)
			{
				if (objectResponse.errorinfo_size() == 0)
				{
					std::cout << "Object abort successfully" << std::endl;
				}
				else
				{
					s3service::errorDetails error = objectResponse.errorinfo(0);

					auto errorCode = error.errorcode();

					std::cout << "Encountered an error abortMultiPartUpload():" << std::endl;
					std::cout << "Error Type:" << error.errortype() << std::endl;
					std::cout << "Error Code: " << error.errorcode() << std::endl;
					std::cout << "Error Message: " << error.errormessage() << std::endl;
				}
			}
			else if(objectOp == s3service::s3object::PUT_MULTIPART)
			{
				if (objectResponse.errorinfo_size() == 0)
				{
					std::cout << "Object put successfully" << std::endl;
				}
				else
				{
					s3service::errorDetails error = objectResponse.errorinfo(0);

					auto errorCode = error.errorcode();

					std::cout << "Encountered an error completeMultiPartUpload():" << std::endl;
					std::cout << "Error Type:" << error.errortype() << std::endl;
					std::cout << "Error Code: " << error.errorcode() << std::endl;
					std::cout << "Error Message: " << error.errormessage() << std::endl;
				}
			}
			else if (objectOp == s3service::s3object::COMPLETE_MULTIPART_OBJECT)
			{
				if (objectResponse.errorinfo_size() == 0)
				{
					std::cout << "Object uploaded successfully" << std::endl;
				}
				else
				{
					s3service::errorDetails error = objectResponse.errorinfo(0);

					auto errorCode = error.errorcode();

					std::cout << "Encountered an error completeMultiPartUpload():" << std::endl;
					std::cout << "Error Type:" << error.errortype() << std::endl;
					std::cout << "Error Code: " << error.errorcode() << std::endl;
					std::cout << "Error Message: " << error.errormessage() << std::endl;
				}
			}
			
			else if (objectOp == s3service::s3object::DELETE_OBJECT)
			{
				if (objectResponse.errorinfo_size() == 0)
				{
					std::cout << "Object deleted successfully" << std::endl;
				}
				else
				{
					s3service::errorDetails error = objectResponse.errorinfo(0);

					auto errorCode = error.errorcode();

					std::cout << "Encountered an error deleteObject():" << std::endl;
					std::cout << "Error Type:" << error.errortype() << std::endl;
					std::cout << "Error Code: " << error.errorcode() << std::endl;
					std::cout << "Error Message: " << error.errormessage() << std::endl;
				}
			}
			
			else if(objectOp == s3service::s3object::LIST_DELETE_MARKER_OBJECT)
			{
				if (objectResponse.errorinfo_size() == 0)
				{
					
					std::cout << objectResponse.listdeletemarker() << std::endl;
				}
				else
				{
					s3service::errorDetails error = objectResponse.errorinfo(0);

					auto errorCode = error.errorcode();

					std::cout << "Encountered an error in Deletemarker ListObject():" << std::endl;
					std::cout << "Error Type:" << error.errortype() << std::endl;
					std::cout << "Error Code: " << error.errorcode() << std::endl;
					std::cout << "Error Message: " << error.errormessage() << std::endl;
				}
			}
			else if (objectOp == s3service::s3object::GET_DELETE_MARKER_OBJECT)
			{
				if (objectResponse.errorinfo_size() == 0)
				{
					std::cout << "Object reterived successfully" << std::endl;
				}
				else
				{
					s3service::errorDetails error = objectResponse.errorinfo(0);

					auto errorCode = error.errorcode();

					std::cout << "Encountered an error getDeleteMarker():" << std::endl;
					std::cout << "Error Type:" << error.errortype() << std::endl;
					std::cout << "Error Code: " << error.errorcode() << std::endl;
					std::cout << "Error Message: " << error.errormessage() << std::endl;
				}
			}
			else if (objectOp == s3service::s3object::GET_OBJECT)
			{
				if (objectResponse.errorinfo_size() == 0)
				{
					std::cout << "Object Retrived successfully" << std::endl;
					writeToFile(csRead, objectResponse.objectname(), objectResponse.len());
				}
				else
				{
					s3service::errorDetails error = objectResponse.errorinfo(0);

					auto errorCode = error.errorcode();

					std::cout << "Encountered an error getBucket():" << std::endl;
					std::cout << "Error Type:" << error.errortype() << std::endl;
					std::cout << "Error Code: " << error.errorcode() << std::endl;
					std::cout << "Error Message: " << error.errormessage() << std::endl;
				}
			}
			
			else if(objectOp == s3service::s3object::PUT_MULTIPART_OBJECT)
			{
				if (objectResponse.errorinfo_size() == 0)
				{
					std::cout << "Object Uploaded successfully" << std::endl;
				}
				else
				{
					s3service::errorDetails error = objectResponse.errorinfo(0);

					auto errorCode = error.errorcode();

					std::cout << "Encountered an error getBucket():" << std::endl;
					std::cout << "Error Type:" << error.errortype() << std::endl;
					std::cout << "Error Code: " << error.errorcode() << std::endl;
					std::cout << "Error Message: " << error.errormessage() << std::endl;
				}
			}
			else if(objectOp == s3service::s3object::GET_OBJECT_BY_VERSION)
			{
				if (objectResponse.errorinfo_size() == 0)
				{
					std::cout << "Object Retrived successfully" << std::endl;
					writeToFile(csRead, objectResponse.objectname(), objectResponse.len());
				}
				else
				{
					s3service::errorDetails error = objectResponse.errorinfo(0);

					auto errorCode = error.errorcode();

					std::cout << "Encountered an error getBucket():" << std::endl;
					std::cout << "Error Type:" << error.errortype() << std::endl;
					std::cout << "Error Code: " << error.errorcode() << std::endl;
					std::cout << "Error Message: " << error.errormessage() << std::endl;
				}
			}

		}
	}
}

int main()
{
	publisher pub("", "", "", "", "requestExchange");

	auto headers = pub.getHeaders();

	headers.insert({"Content-type", "text/text"});
	headers.insert({"Content-encoding", "UTF-8"});

	pub.addHeaders(headers);

	auto err = pub.init();

	if(err.size() != 0)
	{
		std::cout << "Error: " << err << std::endl;
	    return false;
	}

	err = pub.createAndBindQueue("requestQueue", "test");

	if(err.size() != 0)
	{
		std::cout << "Error: " << err << std::endl;
	    return false;
	}

	consumer cObj("", "", "", "", "responseQueue", "client");

	err = cObj.init();

	if (err.size() != 0)
	{
		std::cout << "Error consumer::init(): " << err << std::endl;
		return false;
	}

	err = cObj.bindToExchange("responseExchange", "test");

	if (err.size() != 0)
	{
		std::cout << "Error consumer::bindToExchange(): " << err << std::endl;
		return false;
	}
#ifndef AUTOMATION_FEATURE_ENABLED
	clientSocket csRead("127.0.0.1", 9090);

	 auto ret = csRead.createAndConnect();

	if (ret != "")
	{
		std::cout << "cdRead.createAndConect() failed " << ret << std::endl;
		return -1;
	}
	
	std::thread th1(&createAndPublishRequestPacket, &pub);

	std::thread th2(&consumer::consumeMessage, &cObj);

	while (true)
	{
		for (size_t i = 0; i < consumer::m_consumeRequestMsg.size(); i++)
		{
			s3service::serviceRequestResponse response;

			response.ParseFromString(consumer::m_consumeRequestMsg[i]);

			std::cout << std::endl;
			std::cout << "*****************************************" << std::endl;
			std::cout << std::endl;

			displayConsumedMessage(csRead, response);

			std::cout << std::endl;
			std::cout << "*****************************************" << std::endl;
			std::cout << std::endl;

			consumer::m_consumeRequestMsg.erase(consumer::m_consumeRequestMsg.begin() + i);
			i--;
		}
	}

	th1.join();
	th2.join();
#else
	std::thread th2(&consumer::consumeMessage, &cObj);
	
	clientSocket csRead("127.0.0.1", 9090);

	auto ret = csRead.createAndConnect();

	if (ret != "")
	{
		std::cout << "cdRead.createAndConect() failed " << ret << std::endl;
		return -1;
	}
	
	clientSocket cs("127.0.0.1", 8081);
	
	cs.createAndConnect();
	
	Pistache::Address addr(Pistache::Ipv4::any(), Pistache::Port(8083));
	
	Pistache::Http::Endpoint server(addr);
	
	server.options().threads(1);
	
	Rest::Router router;
	
	Rest::Routes::Get(router, "/client", [&](const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
        	handleOperation(&pub, request, std::move(response));
        	return Pistache::Rest::Route::Result::Ok;
        });
    	server.setHandler(router.handler());
	std::cout<< "starting server on port 8083, http://localhost:8083/client?operation=<Account>&suboperation=<CreateAccount>&accountname=<accountname>&password=<password>"  <<std::endl;
    	server.serve();
    
    	server.shutdown();
    	
	
#endif
    return 0;
}
