// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: s3service.proto

#ifndef PROTOBUF_INCLUDED_s3service_2eproto
#define PROTOBUF_INCLUDED_s3service_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_s3service_2eproto 

namespace protobuf_s3service_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[10];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_s3service_2eproto
namespace s3service {
class S3server;
class S3serverDefaultTypeInternal;
extern S3serverDefaultTypeInternal _S3server_default_instance_;
class errorDetails;
class errorDetailsDefaultTypeInternal;
extern errorDetailsDefaultTypeInternal _errorDetails_default_instance_;
class s3accesskey;
class s3accesskeyDefaultTypeInternal;
extern s3accesskeyDefaultTypeInternal _s3accesskey_default_instance_;
class s3account;
class s3accountDefaultTypeInternal;
extern s3accountDefaultTypeInternal _s3account_default_instance_;
class s3authorization;
class s3authorizationDefaultTypeInternal;
extern s3authorizationDefaultTypeInternal _s3authorization_default_instance_;
class s3bucket;
class s3bucketDefaultTypeInternal;
extern s3bucketDefaultTypeInternal _s3bucket_default_instance_;
class s3object;
class s3objectDefaultTypeInternal;
extern s3objectDefaultTypeInternal _s3object_default_instance_;
class s3user;
class s3userDefaultTypeInternal;
extern s3userDefaultTypeInternal _s3user_default_instance_;
class serviceRequestResponse;
class serviceRequestResponseDefaultTypeInternal;
extern serviceRequestResponseDefaultTypeInternal _serviceRequestResponse_default_instance_;
class tags;
class tagsDefaultTypeInternal;
extern tagsDefaultTypeInternal _tags_default_instance_;
}  // namespace s3service
namespace google {
namespace protobuf {
template<> ::s3service::S3server* Arena::CreateMaybeMessage<::s3service::S3server>(Arena*);
template<> ::s3service::errorDetails* Arena::CreateMaybeMessage<::s3service::errorDetails>(Arena*);
template<> ::s3service::s3accesskey* Arena::CreateMaybeMessage<::s3service::s3accesskey>(Arena*);
template<> ::s3service::s3account* Arena::CreateMaybeMessage<::s3service::s3account>(Arena*);
template<> ::s3service::s3authorization* Arena::CreateMaybeMessage<::s3service::s3authorization>(Arena*);
template<> ::s3service::s3bucket* Arena::CreateMaybeMessage<::s3service::s3bucket>(Arena*);
template<> ::s3service::s3object* Arena::CreateMaybeMessage<::s3service::s3object>(Arena*);
template<> ::s3service::s3user* Arena::CreateMaybeMessage<::s3service::s3user>(Arena*);
template<> ::s3service::serviceRequestResponse* Arena::CreateMaybeMessage<::s3service::serviceRequestResponse>(Arena*);
template<> ::s3service::tags* Arena::CreateMaybeMessage<::s3service::tags>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace s3service {

enum s3accesskey_accesskeyOperation {
  s3accesskey_accesskeyOperation_CREATE_KEY = 0,
  s3accesskey_accesskeyOperation_DELETE_KEY = 1,
  s3accesskey_accesskeyOperation_CHANGE_KEY_STATUS = 2,
  s3accesskey_accesskeyOperation_LAST_USED_TIME = 3,
  s3accesskey_accesskeyOperation_s3accesskey_accesskeyOperation_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  s3accesskey_accesskeyOperation_s3accesskey_accesskeyOperation_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool s3accesskey_accesskeyOperation_IsValid(int value);
const s3accesskey_accesskeyOperation s3accesskey_accesskeyOperation_accesskeyOperation_MIN = s3accesskey_accesskeyOperation_CREATE_KEY;
const s3accesskey_accesskeyOperation s3accesskey_accesskeyOperation_accesskeyOperation_MAX = s3accesskey_accesskeyOperation_LAST_USED_TIME;
const int s3accesskey_accesskeyOperation_accesskeyOperation_ARRAYSIZE = s3accesskey_accesskeyOperation_accesskeyOperation_MAX + 1;

const ::google::protobuf::EnumDescriptor* s3accesskey_accesskeyOperation_descriptor();
inline const ::std::string& s3accesskey_accesskeyOperation_Name(s3accesskey_accesskeyOperation value) {
  return ::google::protobuf::internal::NameOfEnum(
    s3accesskey_accesskeyOperation_descriptor(), value);
}
inline bool s3accesskey_accesskeyOperation_Parse(
    const ::std::string& name, s3accesskey_accesskeyOperation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<s3accesskey_accesskeyOperation>(
    s3accesskey_accesskeyOperation_descriptor(), name, value);
}
enum s3account_accountOperation {
  s3account_accountOperation_CREATE_ACCOUNT = 0,
  s3account_accountOperation_DELETE_ACCOUNT = 1,
  s3account_accountOperation_s3account_accountOperation_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  s3account_accountOperation_s3account_accountOperation_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool s3account_accountOperation_IsValid(int value);
const s3account_accountOperation s3account_accountOperation_accountOperation_MIN = s3account_accountOperation_CREATE_ACCOUNT;
const s3account_accountOperation s3account_accountOperation_accountOperation_MAX = s3account_accountOperation_DELETE_ACCOUNT;
const int s3account_accountOperation_accountOperation_ARRAYSIZE = s3account_accountOperation_accountOperation_MAX + 1;

const ::google::protobuf::EnumDescriptor* s3account_accountOperation_descriptor();
inline const ::std::string& s3account_accountOperation_Name(s3account_accountOperation value) {
  return ::google::protobuf::internal::NameOfEnum(
    s3account_accountOperation_descriptor(), value);
}
inline bool s3account_accountOperation_Parse(
    const ::std::string& name, s3account_accountOperation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<s3account_accountOperation>(
    s3account_accountOperation_descriptor(), name, value);
}
enum s3user_userOperation {
  s3user_userOperation_CREATE_USER = 0,
  s3user_userOperation_DELETE_USER = 1,
  s3user_userOperation_UPDATE_USER = 2,
  s3user_userOperation_s3user_userOperation_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  s3user_userOperation_s3user_userOperation_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool s3user_userOperation_IsValid(int value);
const s3user_userOperation s3user_userOperation_userOperation_MIN = s3user_userOperation_CREATE_USER;
const s3user_userOperation s3user_userOperation_userOperation_MAX = s3user_userOperation_UPDATE_USER;
const int s3user_userOperation_userOperation_ARRAYSIZE = s3user_userOperation_userOperation_MAX + 1;

const ::google::protobuf::EnumDescriptor* s3user_userOperation_descriptor();
inline const ::std::string& s3user_userOperation_Name(s3user_userOperation value) {
  return ::google::protobuf::internal::NameOfEnum(
    s3user_userOperation_descriptor(), value);
}
inline bool s3user_userOperation_Parse(
    const ::std::string& name, s3user_userOperation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<s3user_userOperation>(
    s3user_userOperation_descriptor(), name, value);
}
enum s3bucket_bucketOperation {
  s3bucket_bucketOperation_CREATE_BUCKET = 0,
  s3bucket_bucketOperation_DELETE_BUCKET = 1,
  s3bucket_bucketOperation_LIST_BUCKET = 2,
  s3bucket_bucketOperation_PUT_BUCKET_POLICY = 3,
  s3bucket_bucketOperation_GET_BUCKET_POLICY = 4,
  s3bucket_bucketOperation_PUT_BUCKET_VERSION = 5,
  s3bucket_bucketOperation_GET_BUCKET_VERSION = 6,
  s3bucket_bucketOperation_PUT_BUCKET_TAG = 7,
  s3bucket_bucketOperation_GET_BUCKET_TAG = 8,
  s3bucket_bucketOperation_LIST_OBJECT = 9,
  s3bucket_bucketOperation_LIST_OBJECT_VERSIONS = 10,
  s3bucket_bucketOperation_SET_LIFECYCLE_RULE = 11,
  s3bucket_bucketOperation_SET_STORAGE_QUOTA = 12,
  s3bucket_bucketOperation_GET_STORAGE_LENS = 13,
  s3bucket_bucketOperation_s3bucket_bucketOperation_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  s3bucket_bucketOperation_s3bucket_bucketOperation_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool s3bucket_bucketOperation_IsValid(int value);
const s3bucket_bucketOperation s3bucket_bucketOperation_bucketOperation_MIN = s3bucket_bucketOperation_CREATE_BUCKET;
const s3bucket_bucketOperation s3bucket_bucketOperation_bucketOperation_MAX = s3bucket_bucketOperation_GET_STORAGE_LENS;
const int s3bucket_bucketOperation_bucketOperation_ARRAYSIZE = s3bucket_bucketOperation_bucketOperation_MAX + 1;

const ::google::protobuf::EnumDescriptor* s3bucket_bucketOperation_descriptor();
inline const ::std::string& s3bucket_bucketOperation_Name(s3bucket_bucketOperation value) {
  return ::google::protobuf::internal::NameOfEnum(
    s3bucket_bucketOperation_descriptor(), value);
}
inline bool s3bucket_bucketOperation_Parse(
    const ::std::string& name, s3bucket_bucketOperation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<s3bucket_bucketOperation>(
    s3bucket_bucketOperation_descriptor(), name, value);
}
enum s3object_objectOperation {
  s3object_objectOperation_PUT_OBJECT = 0,
  s3object_objectOperation_GET_OBJECT = 1,
  s3object_objectOperation_DELETE_OBJECT = 2,
  s3object_objectOperation_PUT_MULTIPART_OBJECT = 3,
  s3object_objectOperation_GET_MULTIPART_OBJECT = 4,
  s3object_objectOperation_PUT_TAG = 5,
  s3object_objectOperation_GET_TAG = 6,
  s3object_objectOperation_GET_OBJECT_BY_VERSION = 13,
  s3object_objectOperation_LIST_DELETE_MARKER_OBJECT = 14,
  s3object_objectOperation_GET_DELETE_MARKER_OBJECT = 15,
  s3object_objectOperation_UN_USED = 7,
  s3object_objectOperation_GET_OBJECT_PROP = 8,
  s3object_objectOperation_INIT_MULTIPART_OBJECT = 9,
  s3object_objectOperation_COMPLETE_MULTIPART_OBJECT = 10,
  s3object_objectOperation_ABORT_MULTIPART_OBJECT = 11,
  s3object_objectOperation_LIST_MULTIPART_OBJECT = 12,
  s3object_objectOperation_PUT_MULTIPART = 16,
  s3object_objectOperation_PUT_OBJECT_LOCKING = 17,
  s3object_objectOperation_SET_OBJECT_RETENTION = 18,
  s3object_objectOperation_s3object_objectOperation_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  s3object_objectOperation_s3object_objectOperation_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool s3object_objectOperation_IsValid(int value);
const s3object_objectOperation s3object_objectOperation_objectOperation_MIN = s3object_objectOperation_PUT_OBJECT;
const s3object_objectOperation s3object_objectOperation_objectOperation_MAX = s3object_objectOperation_SET_OBJECT_RETENTION;
const int s3object_objectOperation_objectOperation_ARRAYSIZE = s3object_objectOperation_objectOperation_MAX + 1;

const ::google::protobuf::EnumDescriptor* s3object_objectOperation_descriptor();
inline const ::std::string& s3object_objectOperation_Name(s3object_objectOperation value) {
  return ::google::protobuf::internal::NameOfEnum(
    s3object_objectOperation_descriptor(), value);
}
inline bool s3object_objectOperation_Parse(
    const ::std::string& name, s3object_objectOperation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<s3object_objectOperation>(
    s3object_objectOperation_descriptor(), name, value);
}
enum S3server_serveroperation {
  S3server_serveroperation_Serverdown = 0,
  S3server_serveroperation_S3server_serveroperation_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  S3server_serveroperation_S3server_serveroperation_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool S3server_serveroperation_IsValid(int value);
const S3server_serveroperation S3server_serveroperation_serveroperation_MIN = S3server_serveroperation_Serverdown;
const S3server_serveroperation S3server_serveroperation_serveroperation_MAX = S3server_serveroperation_Serverdown;
const int S3server_serveroperation_serveroperation_ARRAYSIZE = S3server_serveroperation_serveroperation_MAX + 1;

const ::google::protobuf::EnumDescriptor* S3server_serveroperation_descriptor();
inline const ::std::string& S3server_serveroperation_Name(S3server_serveroperation value) {
  return ::google::protobuf::internal::NameOfEnum(
    S3server_serveroperation_descriptor(), value);
}
inline bool S3server_serveroperation_Parse(
    const ::std::string& name, S3server_serveroperation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<S3server_serveroperation>(
    S3server_serveroperation_descriptor(), name, value);
}
enum serviceRequestResponse_serviceEntity {
  serviceRequestResponse_serviceEntity_USER = 0,
  serviceRequestResponse_serviceEntity_ACCOUNT = 1,
  serviceRequestResponse_serviceEntity_BUCKET = 2,
  serviceRequestResponse_serviceEntity_OBJECT = 3,
  serviceRequestResponse_serviceEntity_LOCATION = 4,
  serviceRequestResponse_serviceEntity_ACCESSKEY = 5,
  serviceRequestResponse_serviceEntity_SERVER = 6,
  serviceRequestResponse_serviceEntity_serviceRequestResponse_serviceEntity_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  serviceRequestResponse_serviceEntity_serviceRequestResponse_serviceEntity_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool serviceRequestResponse_serviceEntity_IsValid(int value);
const serviceRequestResponse_serviceEntity serviceRequestResponse_serviceEntity_serviceEntity_MIN = serviceRequestResponse_serviceEntity_USER;
const serviceRequestResponse_serviceEntity serviceRequestResponse_serviceEntity_serviceEntity_MAX = serviceRequestResponse_serviceEntity_SERVER;
const int serviceRequestResponse_serviceEntity_serviceEntity_ARRAYSIZE = serviceRequestResponse_serviceEntity_serviceEntity_MAX + 1;

const ::google::protobuf::EnumDescriptor* serviceRequestResponse_serviceEntity_descriptor();
inline const ::std::string& serviceRequestResponse_serviceEntity_Name(serviceRequestResponse_serviceEntity value) {
  return ::google::protobuf::internal::NameOfEnum(
    serviceRequestResponse_serviceEntity_descriptor(), value);
}
inline bool serviceRequestResponse_serviceEntity_Parse(
    const ::std::string& name, serviceRequestResponse_serviceEntity* value) {
  return ::google::protobuf::internal::ParseNamedEnum<serviceRequestResponse_serviceEntity>(
    serviceRequestResponse_serviceEntity_descriptor(), name, value);
}
// ===================================================================

class s3authorization : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:s3service.s3authorization) */ {
 public:
  s3authorization();
  virtual ~s3authorization();

  s3authorization(const s3authorization& from);

  inline s3authorization& operator=(const s3authorization& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  s3authorization(s3authorization&& from) noexcept
    : s3authorization() {
    *this = ::std::move(from);
  }

  inline s3authorization& operator=(s3authorization&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const s3authorization& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const s3authorization* internal_default_instance() {
    return reinterpret_cast<const s3authorization*>(
               &_s3authorization_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(s3authorization* other);
  friend void swap(s3authorization& a, s3authorization& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline s3authorization* New() const final {
    return CreateMaybeMessage<s3authorization>(NULL);
  }

  s3authorization* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<s3authorization>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const s3authorization& from);
  void MergeFrom(const s3authorization& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(s3authorization* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string accessKey = 1;
  void clear_accesskey();
  static const int kAccessKeyFieldNumber = 1;
  const ::std::string& accesskey() const;
  void set_accesskey(const ::std::string& value);
  #if LANG_CXX11
  void set_accesskey(::std::string&& value);
  #endif
  void set_accesskey(const char* value);
  void set_accesskey(const char* value, size_t size);
  ::std::string* mutable_accesskey();
  ::std::string* release_accesskey();
  void set_allocated_accesskey(::std::string* accesskey);

  // string secretKey = 2;
  void clear_secretkey();
  static const int kSecretKeyFieldNumber = 2;
  const ::std::string& secretkey() const;
  void set_secretkey(const ::std::string& value);
  #if LANG_CXX11
  void set_secretkey(::std::string&& value);
  #endif
  void set_secretkey(const char* value);
  void set_secretkey(const char* value, size_t size);
  ::std::string* mutable_secretkey();
  ::std::string* release_secretkey();
  void set_allocated_secretkey(::std::string* secretkey);

  // @@protoc_insertion_point(class_scope:s3service.s3authorization)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr accesskey_;
  ::google::protobuf::internal::ArenaStringPtr secretkey_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_s3service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class errorDetails : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:s3service.errorDetails) */ {
 public:
  errorDetails();
  virtual ~errorDetails();

  errorDetails(const errorDetails& from);

  inline errorDetails& operator=(const errorDetails& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  errorDetails(errorDetails&& from) noexcept
    : errorDetails() {
    *this = ::std::move(from);
  }

  inline errorDetails& operator=(errorDetails&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const errorDetails& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const errorDetails* internal_default_instance() {
    return reinterpret_cast<const errorDetails*>(
               &_errorDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(errorDetails* other);
  friend void swap(errorDetails& a, errorDetails& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline errorDetails* New() const final {
    return CreateMaybeMessage<errorDetails>(NULL);
  }

  errorDetails* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<errorDetails>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const errorDetails& from);
  void MergeFrom(const errorDetails& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(errorDetails* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string errorMessage = 1;
  void clear_errormessage();
  static const int kErrorMessageFieldNumber = 1;
  const ::std::string& errormessage() const;
  void set_errormessage(const ::std::string& value);
  #if LANG_CXX11
  void set_errormessage(::std::string&& value);
  #endif
  void set_errormessage(const char* value);
  void set_errormessage(const char* value, size_t size);
  ::std::string* mutable_errormessage();
  ::std::string* release_errormessage();
  void set_allocated_errormessage(::std::string* errormessage);

  // string errorType = 2;
  void clear_errortype();
  static const int kErrorTypeFieldNumber = 2;
  const ::std::string& errortype() const;
  void set_errortype(const ::std::string& value);
  #if LANG_CXX11
  void set_errortype(::std::string&& value);
  #endif
  void set_errortype(const char* value);
  void set_errortype(const char* value, size_t size);
  ::std::string* mutable_errortype();
  ::std::string* release_errortype();
  void set_allocated_errortype(::std::string* errortype);

  // string errorCode = 3;
  void clear_errorcode();
  static const int kErrorCodeFieldNumber = 3;
  const ::std::string& errorcode() const;
  void set_errorcode(const ::std::string& value);
  #if LANG_CXX11
  void set_errorcode(::std::string&& value);
  #endif
  void set_errorcode(const char* value);
  void set_errorcode(const char* value, size_t size);
  ::std::string* mutable_errorcode();
  ::std::string* release_errorcode();
  void set_allocated_errorcode(::std::string* errorcode);

  // string hostId = 4;
  void clear_hostid();
  static const int kHostIdFieldNumber = 4;
  const ::std::string& hostid() const;
  void set_hostid(const ::std::string& value);
  #if LANG_CXX11
  void set_hostid(::std::string&& value);
  #endif
  void set_hostid(const char* value);
  void set_hostid(const char* value, size_t size);
  ::std::string* mutable_hostid();
  ::std::string* release_hostid();
  void set_allocated_hostid(::std::string* hostid);

  // string methodType = 5;
  void clear_methodtype();
  static const int kMethodTypeFieldNumber = 5;
  const ::std::string& methodtype() const;
  void set_methodtype(const ::std::string& value);
  #if LANG_CXX11
  void set_methodtype(::std::string&& value);
  #endif
  void set_methodtype(const char* value);
  void set_methodtype(const char* value, size_t size);
  ::std::string* mutable_methodtype();
  ::std::string* release_methodtype();
  void set_allocated_methodtype(::std::string* methodtype);

  // string resourceType = 6;
  void clear_resourcetype();
  static const int kResourceTypeFieldNumber = 6;
  const ::std::string& resourcetype() const;
  void set_resourcetype(const ::std::string& value);
  #if LANG_CXX11
  void set_resourcetype(::std::string&& value);
  #endif
  void set_resourcetype(const char* value);
  void set_resourcetype(const char* value, size_t size);
  ::std::string* mutable_resourcetype();
  ::std::string* release_resourcetype();
  void set_allocated_resourcetype(::std::string* resourcetype);

  // string key = 7;
  void clear_key();
  static const int kKeyFieldNumber = 7;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:s3service.errorDetails)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr errormessage_;
  ::google::protobuf::internal::ArenaStringPtr errortype_;
  ::google::protobuf::internal::ArenaStringPtr errorcode_;
  ::google::protobuf::internal::ArenaStringPtr hostid_;
  ::google::protobuf::internal::ArenaStringPtr methodtype_;
  ::google::protobuf::internal::ArenaStringPtr resourcetype_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_s3service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class s3accesskey : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:s3service.s3accesskey) */ {
 public:
  s3accesskey();
  virtual ~s3accesskey();

  s3accesskey(const s3accesskey& from);

  inline s3accesskey& operator=(const s3accesskey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  s3accesskey(s3accesskey&& from) noexcept
    : s3accesskey() {
    *this = ::std::move(from);
  }

  inline s3accesskey& operator=(s3accesskey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const s3accesskey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const s3accesskey* internal_default_instance() {
    return reinterpret_cast<const s3accesskey*>(
               &_s3accesskey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(s3accesskey* other);
  friend void swap(s3accesskey& a, s3accesskey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline s3accesskey* New() const final {
    return CreateMaybeMessage<s3accesskey>(NULL);
  }

  s3accesskey* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<s3accesskey>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const s3accesskey& from);
  void MergeFrom(const s3accesskey& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(s3accesskey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef s3accesskey_accesskeyOperation accesskeyOperation;
  static const accesskeyOperation CREATE_KEY =
    s3accesskey_accesskeyOperation_CREATE_KEY;
  static const accesskeyOperation DELETE_KEY =
    s3accesskey_accesskeyOperation_DELETE_KEY;
  static const accesskeyOperation CHANGE_KEY_STATUS =
    s3accesskey_accesskeyOperation_CHANGE_KEY_STATUS;
  static const accesskeyOperation LAST_USED_TIME =
    s3accesskey_accesskeyOperation_LAST_USED_TIME;
  static inline bool accesskeyOperation_IsValid(int value) {
    return s3accesskey_accesskeyOperation_IsValid(value);
  }
  static const accesskeyOperation accesskeyOperation_MIN =
    s3accesskey_accesskeyOperation_accesskeyOperation_MIN;
  static const accesskeyOperation accesskeyOperation_MAX =
    s3accesskey_accesskeyOperation_accesskeyOperation_MAX;
  static const int accesskeyOperation_ARRAYSIZE =
    s3accesskey_accesskeyOperation_accesskeyOperation_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  accesskeyOperation_descriptor() {
    return s3accesskey_accesskeyOperation_descriptor();
  }
  static inline const ::std::string& accesskeyOperation_Name(accesskeyOperation value) {
    return s3accesskey_accesskeyOperation_Name(value);
  }
  static inline bool accesskeyOperation_Parse(const ::std::string& name,
      accesskeyOperation* value) {
    return s3accesskey_accesskeyOperation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .s3service.s3authorization auth = 2;
  int auth_size() const;
  void clear_auth();
  static const int kAuthFieldNumber = 2;
  ::s3service::s3authorization* mutable_auth(int index);
  ::google::protobuf::RepeatedPtrField< ::s3service::s3authorization >*
      mutable_auth();
  const ::s3service::s3authorization& auth(int index) const;
  ::s3service::s3authorization* add_auth();
  const ::google::protobuf::RepeatedPtrField< ::s3service::s3authorization >&
      auth() const;

  // repeated .s3service.errorDetails errorInfo = 12;
  int errorinfo_size() const;
  void clear_errorinfo();
  static const int kErrorInfoFieldNumber = 12;
  ::s3service::errorDetails* mutable_errorinfo(int index);
  ::google::protobuf::RepeatedPtrField< ::s3service::errorDetails >*
      mutable_errorinfo();
  const ::s3service::errorDetails& errorinfo(int index) const;
  ::s3service::errorDetails* add_errorinfo();
  const ::google::protobuf::RepeatedPtrField< ::s3service::errorDetails >&
      errorinfo() const;

  // string accessKeyId = 3;
  void clear_accesskeyid();
  static const int kAccessKeyIdFieldNumber = 3;
  const ::std::string& accesskeyid() const;
  void set_accesskeyid(const ::std::string& value);
  #if LANG_CXX11
  void set_accesskeyid(::std::string&& value);
  #endif
  void set_accesskeyid(const char* value);
  void set_accesskeyid(const char* value, size_t size);
  ::std::string* mutable_accesskeyid();
  ::std::string* release_accesskeyid();
  void set_allocated_accesskeyid(::std::string* accesskeyid);

  // string secretKey = 4;
  void clear_secretkey();
  static const int kSecretKeyFieldNumber = 4;
  const ::std::string& secretkey() const;
  void set_secretkey(const ::std::string& value);
  #if LANG_CXX11
  void set_secretkey(::std::string&& value);
  #endif
  void set_secretkey(const char* value);
  void set_secretkey(const char* value, size_t size);
  ::std::string* mutable_secretkey();
  ::std::string* release_secretkey();
  void set_allocated_secretkey(::std::string* secretkey);

  // string accessKeySelector = 5;
  void clear_accesskeyselector();
  static const int kAccessKeySelectorFieldNumber = 5;
  const ::std::string& accesskeyselector() const;
  void set_accesskeyselector(const ::std::string& value);
  #if LANG_CXX11
  void set_accesskeyselector(::std::string&& value);
  #endif
  void set_accesskeyselector(const char* value);
  void set_accesskeyselector(const char* value, size_t size);
  ::std::string* mutable_accesskeyselector();
  ::std::string* release_accesskeyselector();
  void set_allocated_accesskeyselector(::std::string* accesskeyselector);

  // string username = 6;
  void clear_username();
  static const int kUsernameFieldNumber = 6;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // string createDate = 7;
  void clear_createdate();
  static const int kCreateDateFieldNumber = 7;
  const ::std::string& createdate() const;
  void set_createdate(const ::std::string& value);
  #if LANG_CXX11
  void set_createdate(::std::string&& value);
  #endif
  void set_createdate(const char* value);
  void set_createdate(const char* value, size_t size);
  ::std::string* mutable_createdate();
  ::std::string* release_createdate();
  void set_allocated_createdate(::std::string* createdate);

  // string status = 8;
  void clear_status();
  static const int kStatusFieldNumber = 8;
  const ::std::string& status() const;
  void set_status(const ::std::string& value);
  #if LANG_CXX11
  void set_status(::std::string&& value);
  #endif
  void set_status(const char* value);
  void set_status(const char* value, size_t size);
  ::std::string* mutable_status();
  ::std::string* release_status();
  void set_allocated_status(::std::string* status);

  // string lastUsedDate = 9;
  void clear_lastuseddate();
  static const int kLastUsedDateFieldNumber = 9;
  const ::std::string& lastuseddate() const;
  void set_lastuseddate(const ::std::string& value);
  #if LANG_CXX11
  void set_lastuseddate(::std::string&& value);
  #endif
  void set_lastuseddate(const char* value);
  void set_lastuseddate(const char* value, size_t size);
  ::std::string* mutable_lastuseddate();
  ::std::string* release_lastuseddate();
  void set_allocated_lastuseddate(::std::string* lastuseddate);

  // string ServiceName = 10;
  void clear_servicename();
  static const int kServiceNameFieldNumber = 10;
  const ::std::string& servicename() const;
  void set_servicename(const ::std::string& value);
  #if LANG_CXX11
  void set_servicename(::std::string&& value);
  #endif
  void set_servicename(const char* value);
  void set_servicename(const char* value, size_t size);
  ::std::string* mutable_servicename();
  ::std::string* release_servicename();
  void set_allocated_servicename(::std::string* servicename);

  // string Region = 11;
  void clear_region();
  static const int kRegionFieldNumber = 11;
  const ::std::string& region() const;
  void set_region(const ::std::string& value);
  #if LANG_CXX11
  void set_region(::std::string&& value);
  #endif
  void set_region(const char* value);
  void set_region(const char* value, size_t size);
  ::std::string* mutable_region();
  ::std::string* release_region();
  void set_allocated_region(::std::string* region);

  // .s3service.s3accesskey.accesskeyOperation accessOp = 1;
  void clear_accessop();
  static const int kAccessOpFieldNumber = 1;
  ::s3service::s3accesskey_accesskeyOperation accessop() const;
  void set_accessop(::s3service::s3accesskey_accesskeyOperation value);

  // @@protoc_insertion_point(class_scope:s3service.s3accesskey)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::s3service::s3authorization > auth_;
  ::google::protobuf::RepeatedPtrField< ::s3service::errorDetails > errorinfo_;
  ::google::protobuf::internal::ArenaStringPtr accesskeyid_;
  ::google::protobuf::internal::ArenaStringPtr secretkey_;
  ::google::protobuf::internal::ArenaStringPtr accesskeyselector_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr createdate_;
  ::google::protobuf::internal::ArenaStringPtr status_;
  ::google::protobuf::internal::ArenaStringPtr lastuseddate_;
  ::google::protobuf::internal::ArenaStringPtr servicename_;
  ::google::protobuf::internal::ArenaStringPtr region_;
  int accessop_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_s3service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class s3account : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:s3service.s3account) */ {
 public:
  s3account();
  virtual ~s3account();

  s3account(const s3account& from);

  inline s3account& operator=(const s3account& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  s3account(s3account&& from) noexcept
    : s3account() {
    *this = ::std::move(from);
  }

  inline s3account& operator=(s3account&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const s3account& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const s3account* internal_default_instance() {
    return reinterpret_cast<const s3account*>(
               &_s3account_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(s3account* other);
  friend void swap(s3account& a, s3account& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline s3account* New() const final {
    return CreateMaybeMessage<s3account>(NULL);
  }

  s3account* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<s3account>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const s3account& from);
  void MergeFrom(const s3account& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(s3account* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef s3account_accountOperation accountOperation;
  static const accountOperation CREATE_ACCOUNT =
    s3account_accountOperation_CREATE_ACCOUNT;
  static const accountOperation DELETE_ACCOUNT =
    s3account_accountOperation_DELETE_ACCOUNT;
  static inline bool accountOperation_IsValid(int value) {
    return s3account_accountOperation_IsValid(value);
  }
  static const accountOperation accountOperation_MIN =
    s3account_accountOperation_accountOperation_MIN;
  static const accountOperation accountOperation_MAX =
    s3account_accountOperation_accountOperation_MAX;
  static const int accountOperation_ARRAYSIZE =
    s3account_accountOperation_accountOperation_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  accountOperation_descriptor() {
    return s3account_accountOperation_descriptor();
  }
  static inline const ::std::string& accountOperation_Name(accountOperation value) {
    return s3account_accountOperation_Name(value);
  }
  static inline bool accountOperation_Parse(const ::std::string& name,
      accountOperation* value) {
    return s3account_accountOperation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .s3service.s3accesskey keys = 5;
  int keys_size() const;
  void clear_keys();
  static const int kKeysFieldNumber = 5;
  ::s3service::s3accesskey* mutable_keys(int index);
  ::google::protobuf::RepeatedPtrField< ::s3service::s3accesskey >*
      mutable_keys();
  const ::s3service::s3accesskey& keys(int index) const;
  ::s3service::s3accesskey* add_keys();
  const ::google::protobuf::RepeatedPtrField< ::s3service::s3accesskey >&
      keys() const;

  // repeated .s3service.errorDetails errorInfo = 6;
  int errorinfo_size() const;
  void clear_errorinfo();
  static const int kErrorInfoFieldNumber = 6;
  ::s3service::errorDetails* mutable_errorinfo(int index);
  ::google::protobuf::RepeatedPtrField< ::s3service::errorDetails >*
      mutable_errorinfo();
  const ::s3service::errorDetails& errorinfo(int index) const;
  ::s3service::errorDetails* add_errorinfo();
  const ::google::protobuf::RepeatedPtrField< ::s3service::errorDetails >&
      errorinfo() const;

  // string accountname = 2;
  void clear_accountname();
  static const int kAccountnameFieldNumber = 2;
  const ::std::string& accountname() const;
  void set_accountname(const ::std::string& value);
  #if LANG_CXX11
  void set_accountname(::std::string&& value);
  #endif
  void set_accountname(const char* value);
  void set_accountname(const char* value, size_t size);
  ::std::string* mutable_accountname();
  ::std::string* release_accountname();
  void set_allocated_accountname(::std::string* accountname);

  // string password = 3;
  void clear_password();
  static const int kPasswordFieldNumber = 3;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // string accountId = 4;
  void clear_accountid();
  static const int kAccountIdFieldNumber = 4;
  const ::std::string& accountid() const;
  void set_accountid(const ::std::string& value);
  #if LANG_CXX11
  void set_accountid(::std::string&& value);
  #endif
  void set_accountid(const char* value);
  void set_accountid(const char* value, size_t size);
  ::std::string* mutable_accountid();
  ::std::string* release_accountid();
  void set_allocated_accountid(::std::string* accountid);

  // .s3service.s3account.accountOperation accOp = 1;
  void clear_accop();
  static const int kAccOpFieldNumber = 1;
  ::s3service::s3account_accountOperation accop() const;
  void set_accop(::s3service::s3account_accountOperation value);

  // @@protoc_insertion_point(class_scope:s3service.s3account)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::s3service::s3accesskey > keys_;
  ::google::protobuf::RepeatedPtrField< ::s3service::errorDetails > errorinfo_;
  ::google::protobuf::internal::ArenaStringPtr accountname_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::google::protobuf::internal::ArenaStringPtr accountid_;
  int accop_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_s3service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class s3user : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:s3service.s3user) */ {
 public:
  s3user();
  virtual ~s3user();

  s3user(const s3user& from);

  inline s3user& operator=(const s3user& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  s3user(s3user&& from) noexcept
    : s3user() {
    *this = ::std::move(from);
  }

  inline s3user& operator=(s3user&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const s3user& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const s3user* internal_default_instance() {
    return reinterpret_cast<const s3user*>(
               &_s3user_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(s3user* other);
  friend void swap(s3user& a, s3user& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline s3user* New() const final {
    return CreateMaybeMessage<s3user>(NULL);
  }

  s3user* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<s3user>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const s3user& from);
  void MergeFrom(const s3user& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(s3user* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef s3user_userOperation userOperation;
  static const userOperation CREATE_USER =
    s3user_userOperation_CREATE_USER;
  static const userOperation DELETE_USER =
    s3user_userOperation_DELETE_USER;
  static const userOperation UPDATE_USER =
    s3user_userOperation_UPDATE_USER;
  static inline bool userOperation_IsValid(int value) {
    return s3user_userOperation_IsValid(value);
  }
  static const userOperation userOperation_MIN =
    s3user_userOperation_userOperation_MIN;
  static const userOperation userOperation_MAX =
    s3user_userOperation_userOperation_MAX;
  static const int userOperation_ARRAYSIZE =
    s3user_userOperation_userOperation_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  userOperation_descriptor() {
    return s3user_userOperation_descriptor();
  }
  static inline const ::std::string& userOperation_Name(userOperation value) {
    return s3user_userOperation_Name(value);
  }
  static inline bool userOperation_Parse(const ::std::string& name,
      userOperation* value) {
    return s3user_userOperation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .s3service.s3authorization auth = 3;
  int auth_size() const;
  void clear_auth();
  static const int kAuthFieldNumber = 3;
  ::s3service::s3authorization* mutable_auth(int index);
  ::google::protobuf::RepeatedPtrField< ::s3service::s3authorization >*
      mutable_auth();
  const ::s3service::s3authorization& auth(int index) const;
  ::s3service::s3authorization* add_auth();
  const ::google::protobuf::RepeatedPtrField< ::s3service::s3authorization >&
      auth() const;

  // repeated .s3service.errorDetails errorInfo = 4;
  int errorinfo_size() const;
  void clear_errorinfo();
  static const int kErrorInfoFieldNumber = 4;
  ::s3service::errorDetails* mutable_errorinfo(int index);
  ::google::protobuf::RepeatedPtrField< ::s3service::errorDetails >*
      mutable_errorinfo();
  const ::s3service::errorDetails& errorinfo(int index) const;
  ::s3service::errorDetails* add_errorinfo();
  const ::google::protobuf::RepeatedPtrField< ::s3service::errorDetails >&
      errorinfo() const;

  // string username = 2;
  void clear_username();
  static const int kUsernameFieldNumber = 2;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // string newusername = 5;
  void clear_newusername();
  static const int kNewusernameFieldNumber = 5;
  const ::std::string& newusername() const;
  void set_newusername(const ::std::string& value);
  #if LANG_CXX11
  void set_newusername(::std::string&& value);
  #endif
  void set_newusername(const char* value);
  void set_newusername(const char* value, size_t size);
  ::std::string* mutable_newusername();
  ::std::string* release_newusername();
  void set_allocated_newusername(::std::string* newusername);

  // string permission = 6;
  void clear_permission();
  static const int kPermissionFieldNumber = 6;
  const ::std::string& permission() const;
  void set_permission(const ::std::string& value);
  #if LANG_CXX11
  void set_permission(::std::string&& value);
  #endif
  void set_permission(const char* value);
  void set_permission(const char* value, size_t size);
  ::std::string* mutable_permission();
  ::std::string* release_permission();
  void set_allocated_permission(::std::string* permission);

  // string test = 7;
  void clear_test();
  static const int kTestFieldNumber = 7;
  const ::std::string& test() const;
  void set_test(const ::std::string& value);
  #if LANG_CXX11
  void set_test(::std::string&& value);
  #endif
  void set_test(const char* value);
  void set_test(const char* value, size_t size);
  ::std::string* mutable_test();
  ::std::string* release_test();
  void set_allocated_test(::std::string* test);

  // string userID = 8;
  void clear_userid();
  static const int kUserIDFieldNumber = 8;
  const ::std::string& userid() const;
  void set_userid(const ::std::string& value);
  #if LANG_CXX11
  void set_userid(::std::string&& value);
  #endif
  void set_userid(const char* value);
  void set_userid(const char* value, size_t size);
  ::std::string* mutable_userid();
  ::std::string* release_userid();
  void set_allocated_userid(::std::string* userid);

  // string createDate = 9;
  void clear_createdate();
  static const int kCreateDateFieldNumber = 9;
  const ::std::string& createdate() const;
  void set_createdate(const ::std::string& value);
  #if LANG_CXX11
  void set_createdate(::std::string&& value);
  #endif
  void set_createdate(const char* value);
  void set_createdate(const char* value, size_t size);
  ::std::string* mutable_createdate();
  ::std::string* release_createdate();
  void set_allocated_createdate(::std::string* createdate);

  // string arn = 10;
  void clear_arn();
  static const int kArnFieldNumber = 10;
  const ::std::string& arn() const;
  void set_arn(const ::std::string& value);
  #if LANG_CXX11
  void set_arn(::std::string&& value);
  #endif
  void set_arn(const char* value);
  void set_arn(const char* value, size_t size);
  ::std::string* mutable_arn();
  ::std::string* release_arn();
  void set_allocated_arn(::std::string* arn);

  // string path = 11;
  void clear_path();
  static const int kPathFieldNumber = 11;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // .s3service.s3user.userOperation userOp = 1;
  void clear_userop();
  static const int kUserOpFieldNumber = 1;
  ::s3service::s3user_userOperation userop() const;
  void set_userop(::s3service::s3user_userOperation value);

  // @@protoc_insertion_point(class_scope:s3service.s3user)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::s3service::s3authorization > auth_;
  ::google::protobuf::RepeatedPtrField< ::s3service::errorDetails > errorinfo_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr newusername_;
  ::google::protobuf::internal::ArenaStringPtr permission_;
  ::google::protobuf::internal::ArenaStringPtr test_;
  ::google::protobuf::internal::ArenaStringPtr userid_;
  ::google::protobuf::internal::ArenaStringPtr createdate_;
  ::google::protobuf::internal::ArenaStringPtr arn_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  int userop_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_s3service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class tags : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:s3service.tags) */ {
 public:
  tags();
  virtual ~tags();

  tags(const tags& from);

  inline tags& operator=(const tags& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  tags(tags&& from) noexcept
    : tags() {
    *this = ::std::move(from);
  }

  inline tags& operator=(tags&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const tags& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const tags* internal_default_instance() {
    return reinterpret_cast<const tags*>(
               &_tags_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(tags* other);
  friend void swap(tags& a, tags& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline tags* New() const final {
    return CreateMaybeMessage<tags>(NULL);
  }

  tags* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<tags>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const tags& from);
  void MergeFrom(const tags& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(tags* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // string value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:s3service.tags)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_s3service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class s3bucket : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:s3service.s3bucket) */ {
 public:
  s3bucket();
  virtual ~s3bucket();

  s3bucket(const s3bucket& from);

  inline s3bucket& operator=(const s3bucket& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  s3bucket(s3bucket&& from) noexcept
    : s3bucket() {
    *this = ::std::move(from);
  }

  inline s3bucket& operator=(s3bucket&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const s3bucket& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const s3bucket* internal_default_instance() {
    return reinterpret_cast<const s3bucket*>(
               &_s3bucket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(s3bucket* other);
  friend void swap(s3bucket& a, s3bucket& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline s3bucket* New() const final {
    return CreateMaybeMessage<s3bucket>(NULL);
  }

  s3bucket* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<s3bucket>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const s3bucket& from);
  void MergeFrom(const s3bucket& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(s3bucket* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef s3bucket_bucketOperation bucketOperation;
  static const bucketOperation CREATE_BUCKET =
    s3bucket_bucketOperation_CREATE_BUCKET;
  static const bucketOperation DELETE_BUCKET =
    s3bucket_bucketOperation_DELETE_BUCKET;
  static const bucketOperation LIST_BUCKET =
    s3bucket_bucketOperation_LIST_BUCKET;
  static const bucketOperation PUT_BUCKET_POLICY =
    s3bucket_bucketOperation_PUT_BUCKET_POLICY;
  static const bucketOperation GET_BUCKET_POLICY =
    s3bucket_bucketOperation_GET_BUCKET_POLICY;
  static const bucketOperation PUT_BUCKET_VERSION =
    s3bucket_bucketOperation_PUT_BUCKET_VERSION;
  static const bucketOperation GET_BUCKET_VERSION =
    s3bucket_bucketOperation_GET_BUCKET_VERSION;
  static const bucketOperation PUT_BUCKET_TAG =
    s3bucket_bucketOperation_PUT_BUCKET_TAG;
  static const bucketOperation GET_BUCKET_TAG =
    s3bucket_bucketOperation_GET_BUCKET_TAG;
  static const bucketOperation LIST_OBJECT =
    s3bucket_bucketOperation_LIST_OBJECT;
  static const bucketOperation LIST_OBJECT_VERSIONS =
    s3bucket_bucketOperation_LIST_OBJECT_VERSIONS;
  static const bucketOperation SET_LIFECYCLE_RULE =
    s3bucket_bucketOperation_SET_LIFECYCLE_RULE;
  static const bucketOperation SET_STORAGE_QUOTA =
    s3bucket_bucketOperation_SET_STORAGE_QUOTA;
  static const bucketOperation GET_STORAGE_LENS =
    s3bucket_bucketOperation_GET_STORAGE_LENS;
  static inline bool bucketOperation_IsValid(int value) {
    return s3bucket_bucketOperation_IsValid(value);
  }
  static const bucketOperation bucketOperation_MIN =
    s3bucket_bucketOperation_bucketOperation_MIN;
  static const bucketOperation bucketOperation_MAX =
    s3bucket_bucketOperation_bucketOperation_MAX;
  static const int bucketOperation_ARRAYSIZE =
    s3bucket_bucketOperation_bucketOperation_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  bucketOperation_descriptor() {
    return s3bucket_bucketOperation_descriptor();
  }
  static inline const ::std::string& bucketOperation_Name(bucketOperation value) {
    return s3bucket_bucketOperation_Name(value);
  }
  static inline bool bucketOperation_Parse(const ::std::string& name,
      bucketOperation* value) {
    return s3bucket_bucketOperation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .s3service.s3authorization auth = 2;
  int auth_size() const;
  void clear_auth();
  static const int kAuthFieldNumber = 2;
  ::s3service::s3authorization* mutable_auth(int index);
  ::google::protobuf::RepeatedPtrField< ::s3service::s3authorization >*
      mutable_auth();
  const ::s3service::s3authorization& auth(int index) const;
  ::s3service::s3authorization* add_auth();
  const ::google::protobuf::RepeatedPtrField< ::s3service::s3authorization >&
      auth() const;

  // repeated .s3service.tags tag = 3;
  int tag_size() const;
  void clear_tag();
  static const int kTagFieldNumber = 3;
  ::s3service::tags* mutable_tag(int index);
  ::google::protobuf::RepeatedPtrField< ::s3service::tags >*
      mutable_tag();
  const ::s3service::tags& tag(int index) const;
  ::s3service::tags* add_tag();
  const ::google::protobuf::RepeatedPtrField< ::s3service::tags >&
      tag() const;

  // repeated .s3service.errorDetails errorInfo = 4;
  int errorinfo_size() const;
  void clear_errorinfo();
  static const int kErrorInfoFieldNumber = 4;
  ::s3service::errorDetails* mutable_errorinfo(int index);
  ::google::protobuf::RepeatedPtrField< ::s3service::errorDetails >*
      mutable_errorinfo();
  const ::s3service::errorDetails& errorinfo(int index) const;
  ::s3service::errorDetails* add_errorinfo();
  const ::google::protobuf::RepeatedPtrField< ::s3service::errorDetails >&
      errorinfo() const;

  // string bucketName = 5;
  void clear_bucketname();
  static const int kBucketNameFieldNumber = 5;
  const ::std::string& bucketname() const;
  void set_bucketname(const ::std::string& value);
  #if LANG_CXX11
  void set_bucketname(::std::string&& value);
  #endif
  void set_bucketname(const char* value);
  void set_bucketname(const char* value, size_t size);
  ::std::string* mutable_bucketname();
  ::std::string* release_bucketname();
  void set_allocated_bucketname(::std::string* bucketname);

  // string version = 8;
  void clear_version();
  static const int kVersionFieldNumber = 8;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // string list_object = 9;
  void clear_list_object();
  static const int kListObjectFieldNumber = 9;
  const ::std::string& list_object() const;
  void set_list_object(const ::std::string& value);
  #if LANG_CXX11
  void set_list_object(::std::string&& value);
  #endif
  void set_list_object(const char* value);
  void set_list_object(const char* value, size_t size);
  ::std::string* mutable_list_object();
  ::std::string* release_list_object();
  void set_allocated_list_object(::std::string* list_object);

  // string list_object_versions = 10;
  void clear_list_object_versions();
  static const int kListObjectVersionsFieldNumber = 10;
  const ::std::string& list_object_versions() const;
  void set_list_object_versions(const ::std::string& value);
  #if LANG_CXX11
  void set_list_object_versions(::std::string&& value);
  #endif
  void set_list_object_versions(const char* value);
  void set_list_object_versions(const char* value, size_t size);
  ::std::string* mutable_list_object_versions();
  ::std::string* release_list_object_versions();
  void set_allocated_list_object_versions(::std::string* list_object_versions);

  // string archive = 11;
  void clear_archive();
  static const int kArchiveFieldNumber = 11;
  const ::std::string& archive() const;
  void set_archive(const ::std::string& value);
  #if LANG_CXX11
  void set_archive(::std::string&& value);
  #endif
  void set_archive(const char* value);
  void set_archive(const char* value, size_t size);
  ::std::string* mutable_archive();
  ::std::string* release_archive();
  void set_allocated_archive(::std::string* archive);

  // string expiry_date = 12;
  void clear_expiry_date();
  static const int kExpiryDateFieldNumber = 12;
  const ::std::string& expiry_date() const;
  void set_expiry_date(const ::std::string& value);
  #if LANG_CXX11
  void set_expiry_date(::std::string&& value);
  #endif
  void set_expiry_date(const char* value);
  void set_expiry_date(const char* value, size_t size);
  ::std::string* mutable_expiry_date();
  ::std::string* release_expiry_date();
  void set_allocated_expiry_date(::std::string* expiry_date);

  // string storageQuota = 13;
  void clear_storagequota();
  static const int kStorageQuotaFieldNumber = 13;
  const ::std::string& storagequota() const;
  void set_storagequota(const ::std::string& value);
  #if LANG_CXX11
  void set_storagequota(::std::string&& value);
  #endif
  void set_storagequota(const char* value);
  void set_storagequota(const char* value, size_t size);
  ::std::string* mutable_storagequota();
  ::std::string* release_storagequota();
  void set_allocated_storagequota(::std::string* storagequota);

  // string storageLens = 14;
  void clear_storagelens();
  static const int kStorageLensFieldNumber = 14;
  const ::std::string& storagelens() const;
  void set_storagelens(const ::std::string& value);
  #if LANG_CXX11
  void set_storagelens(::std::string&& value);
  #endif
  void set_storagelens(const char* value);
  void set_storagelens(const char* value, size_t size);
  ::std::string* mutable_storagelens();
  ::std::string* release_storagelens();
  void set_allocated_storagelens(::std::string* storagelens);

  // string total_size = 15;
  void clear_total_size();
  static const int kTotalSizeFieldNumber = 15;
  const ::std::string& total_size() const;
  void set_total_size(const ::std::string& value);
  #if LANG_CXX11
  void set_total_size(::std::string&& value);
  #endif
  void set_total_size(const char* value);
  void set_total_size(const char* value, size_t size);
  ::std::string* mutable_total_size();
  ::std::string* release_total_size();
  void set_allocated_total_size(::std::string* total_size);

  // string size_consumed = 16;
  void clear_size_consumed();
  static const int kSizeConsumedFieldNumber = 16;
  const ::std::string& size_consumed() const;
  void set_size_consumed(const ::std::string& value);
  #if LANG_CXX11
  void set_size_consumed(::std::string&& value);
  #endif
  void set_size_consumed(const char* value);
  void set_size_consumed(const char* value, size_t size);
  ::std::string* mutable_size_consumed();
  ::std::string* release_size_consumed();
  void set_allocated_size_consumed(::std::string* size_consumed);

  // string free_space = 17;
  void clear_free_space();
  static const int kFreeSpaceFieldNumber = 17;
  const ::std::string& free_space() const;
  void set_free_space(const ::std::string& value);
  #if LANG_CXX11
  void set_free_space(::std::string&& value);
  #endif
  void set_free_space(const char* value);
  void set_free_space(const char* value, size_t size);
  ::std::string* mutable_free_space();
  ::std::string* release_free_space();
  void set_allocated_free_space(::std::string* free_space);

  // .s3service.s3user currentUser = 6;
  bool has_currentuser() const;
  void clear_currentuser();
  static const int kCurrentUserFieldNumber = 6;
  private:
  const ::s3service::s3user& _internal_currentuser() const;
  public:
  const ::s3service::s3user& currentuser() const;
  ::s3service::s3user* release_currentuser();
  ::s3service::s3user* mutable_currentuser();
  void set_allocated_currentuser(::s3service::s3user* currentuser);

  // .s3service.s3user bucketOwner = 7;
  bool has_bucketowner() const;
  void clear_bucketowner();
  static const int kBucketOwnerFieldNumber = 7;
  private:
  const ::s3service::s3user& _internal_bucketowner() const;
  public:
  const ::s3service::s3user& bucketowner() const;
  ::s3service::s3user* release_bucketowner();
  ::s3service::s3user* mutable_bucketowner();
  void set_allocated_bucketowner(::s3service::s3user* bucketowner);

  // .s3service.s3bucket.bucketOperation buckOp = 1;
  void clear_buckop();
  static const int kBuckOpFieldNumber = 1;
  ::s3service::s3bucket_bucketOperation buckop() const;
  void set_buckop(::s3service::s3bucket_bucketOperation value);

  // @@protoc_insertion_point(class_scope:s3service.s3bucket)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::s3service::s3authorization > auth_;
  ::google::protobuf::RepeatedPtrField< ::s3service::tags > tag_;
  ::google::protobuf::RepeatedPtrField< ::s3service::errorDetails > errorinfo_;
  ::google::protobuf::internal::ArenaStringPtr bucketname_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr list_object_;
  ::google::protobuf::internal::ArenaStringPtr list_object_versions_;
  ::google::protobuf::internal::ArenaStringPtr archive_;
  ::google::protobuf::internal::ArenaStringPtr expiry_date_;
  ::google::protobuf::internal::ArenaStringPtr storagequota_;
  ::google::protobuf::internal::ArenaStringPtr storagelens_;
  ::google::protobuf::internal::ArenaStringPtr total_size_;
  ::google::protobuf::internal::ArenaStringPtr size_consumed_;
  ::google::protobuf::internal::ArenaStringPtr free_space_;
  ::s3service::s3user* currentuser_;
  ::s3service::s3user* bucketowner_;
  int buckop_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_s3service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class s3object : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:s3service.s3object) */ {
 public:
  s3object();
  virtual ~s3object();

  s3object(const s3object& from);

  inline s3object& operator=(const s3object& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  s3object(s3object&& from) noexcept
    : s3object() {
    *this = ::std::move(from);
  }

  inline s3object& operator=(s3object&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const s3object& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const s3object* internal_default_instance() {
    return reinterpret_cast<const s3object*>(
               &_s3object_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(s3object* other);
  friend void swap(s3object& a, s3object& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline s3object* New() const final {
    return CreateMaybeMessage<s3object>(NULL);
  }

  s3object* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<s3object>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const s3object& from);
  void MergeFrom(const s3object& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(s3object* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef s3object_objectOperation objectOperation;
  static const objectOperation PUT_OBJECT =
    s3object_objectOperation_PUT_OBJECT;
  static const objectOperation GET_OBJECT =
    s3object_objectOperation_GET_OBJECT;
  static const objectOperation DELETE_OBJECT =
    s3object_objectOperation_DELETE_OBJECT;
  static const objectOperation PUT_MULTIPART_OBJECT =
    s3object_objectOperation_PUT_MULTIPART_OBJECT;
  static const objectOperation GET_MULTIPART_OBJECT =
    s3object_objectOperation_GET_MULTIPART_OBJECT;
  static const objectOperation PUT_TAG =
    s3object_objectOperation_PUT_TAG;
  static const objectOperation GET_TAG =
    s3object_objectOperation_GET_TAG;
  static const objectOperation GET_OBJECT_BY_VERSION =
    s3object_objectOperation_GET_OBJECT_BY_VERSION;
  static const objectOperation LIST_DELETE_MARKER_OBJECT =
    s3object_objectOperation_LIST_DELETE_MARKER_OBJECT;
  static const objectOperation GET_DELETE_MARKER_OBJECT =
    s3object_objectOperation_GET_DELETE_MARKER_OBJECT;
  static const objectOperation UN_USED =
    s3object_objectOperation_UN_USED;
  static const objectOperation GET_OBJECT_PROP =
    s3object_objectOperation_GET_OBJECT_PROP;
  static const objectOperation INIT_MULTIPART_OBJECT =
    s3object_objectOperation_INIT_MULTIPART_OBJECT;
  static const objectOperation COMPLETE_MULTIPART_OBJECT =
    s3object_objectOperation_COMPLETE_MULTIPART_OBJECT;
  static const objectOperation ABORT_MULTIPART_OBJECT =
    s3object_objectOperation_ABORT_MULTIPART_OBJECT;
  static const objectOperation LIST_MULTIPART_OBJECT =
    s3object_objectOperation_LIST_MULTIPART_OBJECT;
  static const objectOperation PUT_MULTIPART =
    s3object_objectOperation_PUT_MULTIPART;
  static const objectOperation PUT_OBJECT_LOCKING =
    s3object_objectOperation_PUT_OBJECT_LOCKING;
  static const objectOperation SET_OBJECT_RETENTION =
    s3object_objectOperation_SET_OBJECT_RETENTION;
  static inline bool objectOperation_IsValid(int value) {
    return s3object_objectOperation_IsValid(value);
  }
  static const objectOperation objectOperation_MIN =
    s3object_objectOperation_objectOperation_MIN;
  static const objectOperation objectOperation_MAX =
    s3object_objectOperation_objectOperation_MAX;
  static const int objectOperation_ARRAYSIZE =
    s3object_objectOperation_objectOperation_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  objectOperation_descriptor() {
    return s3object_objectOperation_descriptor();
  }
  static inline const ::std::string& objectOperation_Name(objectOperation value) {
    return s3object_objectOperation_Name(value);
  }
  static inline bool objectOperation_Parse(const ::std::string& name,
      objectOperation* value) {
    return s3object_objectOperation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .s3service.s3authorization auth = 2;
  int auth_size() const;
  void clear_auth();
  static const int kAuthFieldNumber = 2;
  ::s3service::s3authorization* mutable_auth(int index);
  ::google::protobuf::RepeatedPtrField< ::s3service::s3authorization >*
      mutable_auth();
  const ::s3service::s3authorization& auth(int index) const;
  ::s3service::s3authorization* add_auth();
  const ::google::protobuf::RepeatedPtrField< ::s3service::s3authorization >&
      auth() const;

  // repeated .s3service.errorDetails errorInfo = 3;
  int errorinfo_size() const;
  void clear_errorinfo();
  static const int kErrorInfoFieldNumber = 3;
  ::s3service::errorDetails* mutable_errorinfo(int index);
  ::google::protobuf::RepeatedPtrField< ::s3service::errorDetails >*
      mutable_errorinfo();
  const ::s3service::errorDetails& errorinfo(int index) const;
  ::s3service::errorDetails* add_errorinfo();
  const ::google::protobuf::RepeatedPtrField< ::s3service::errorDetails >&
      errorinfo() const;

  // repeated string multiPartList = 11;
  int multipartlist_size() const;
  void clear_multipartlist();
  static const int kMultiPartListFieldNumber = 11;
  const ::std::string& multipartlist(int index) const;
  ::std::string* mutable_multipartlist(int index);
  void set_multipartlist(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_multipartlist(int index, ::std::string&& value);
  #endif
  void set_multipartlist(int index, const char* value);
  void set_multipartlist(int index, const char* value, size_t size);
  ::std::string* add_multipartlist();
  void add_multipartlist(const ::std::string& value);
  #if LANG_CXX11
  void add_multipartlist(::std::string&& value);
  #endif
  void add_multipartlist(const char* value);
  void add_multipartlist(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& multipartlist() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_multipartlist();

  // string bucketName = 4;
  void clear_bucketname();
  static const int kBucketNameFieldNumber = 4;
  const ::std::string& bucketname() const;
  void set_bucketname(const ::std::string& value);
  #if LANG_CXX11
  void set_bucketname(::std::string&& value);
  #endif
  void set_bucketname(const char* value);
  void set_bucketname(const char* value, size_t size);
  ::std::string* mutable_bucketname();
  ::std::string* release_bucketname();
  void set_allocated_bucketname(::std::string* bucketname);

  // string objectName = 5;
  void clear_objectname();
  static const int kObjectNameFieldNumber = 5;
  const ::std::string& objectname() const;
  void set_objectname(const ::std::string& value);
  #if LANG_CXX11
  void set_objectname(::std::string&& value);
  #endif
  void set_objectname(const char* value);
  void set_objectname(const char* value, size_t size);
  ::std::string* mutable_objectname();
  ::std::string* release_objectname();
  void set_allocated_objectname(::std::string* objectname);

  // string objectPath = 7;
  void clear_objectpath();
  static const int kObjectPathFieldNumber = 7;
  const ::std::string& objectpath() const;
  void set_objectpath(const ::std::string& value);
  #if LANG_CXX11
  void set_objectpath(::std::string&& value);
  #endif
  void set_objectpath(const char* value);
  void set_objectpath(const char* value, size_t size);
  ::std::string* mutable_objectpath();
  ::std::string* release_objectpath();
  void set_allocated_objectpath(::std::string* objectpath);

  // string tag = 8;
  void clear_tag();
  static const int kTagFieldNumber = 8;
  const ::std::string& tag() const;
  void set_tag(const ::std::string& value);
  #if LANG_CXX11
  void set_tag(::std::string&& value);
  #endif
  void set_tag(const char* value);
  void set_tag(const char* value, size_t size);
  ::std::string* mutable_tag();
  ::std::string* release_tag();
  void set_allocated_tag(::std::string* tag);

  // string putId = 9;
  void clear_putid();
  static const int kPutIdFieldNumber = 9;
  const ::std::string& putid() const;
  void set_putid(const ::std::string& value);
  #if LANG_CXX11
  void set_putid(::std::string&& value);
  #endif
  void set_putid(const char* value);
  void set_putid(const char* value, size_t size);
  ::std::string* mutable_putid();
  ::std::string* release_putid();
  void set_allocated_putid(::std::string* putid);

  // string versionId = 10;
  void clear_versionid();
  static const int kVersionIdFieldNumber = 10;
  const ::std::string& versionid() const;
  void set_versionid(const ::std::string& value);
  #if LANG_CXX11
  void set_versionid(::std::string&& value);
  #endif
  void set_versionid(const char* value);
  void set_versionid(const char* value, size_t size);
  ::std::string* mutable_versionid();
  ::std::string* release_versionid();
  void set_allocated_versionid(::std::string* versionid);

  // string multiPartNo = 12;
  void clear_multipartno();
  static const int kMultiPartNoFieldNumber = 12;
  const ::std::string& multipartno() const;
  void set_multipartno(const ::std::string& value);
  #if LANG_CXX11
  void set_multipartno(::std::string&& value);
  #endif
  void set_multipartno(const char* value);
  void set_multipartno(const char* value, size_t size);
  ::std::string* mutable_multipartno();
  ::std::string* release_multipartno();
  void set_allocated_multipartno(::std::string* multipartno);

  // string multiPartUniqueId = 13;
  void clear_multipartuniqueid();
  static const int kMultiPartUniqueIdFieldNumber = 13;
  const ::std::string& multipartuniqueid() const;
  void set_multipartuniqueid(const ::std::string& value);
  #if LANG_CXX11
  void set_multipartuniqueid(::std::string&& value);
  #endif
  void set_multipartuniqueid(const char* value);
  void set_multipartuniqueid(const char* value, size_t size);
  ::std::string* mutable_multipartuniqueid();
  ::std::string* release_multipartuniqueid();
  void set_allocated_multipartuniqueid(::std::string* multipartuniqueid);

  // string list_object = 14;
  void clear_list_object();
  static const int kListObjectFieldNumber = 14;
  const ::std::string& list_object() const;
  void set_list_object(const ::std::string& value);
  #if LANG_CXX11
  void set_list_object(::std::string&& value);
  #endif
  void set_list_object(const char* value);
  void set_list_object(const char* value, size_t size);
  ::std::string* mutable_list_object();
  ::std::string* release_list_object();
  void set_allocated_list_object(::std::string* list_object);

  // string getobjectbyversionId = 15;
  void clear_getobjectbyversionid();
  static const int kGetobjectbyversionIdFieldNumber = 15;
  const ::std::string& getobjectbyversionid() const;
  void set_getobjectbyversionid(const ::std::string& value);
  #if LANG_CXX11
  void set_getobjectbyversionid(::std::string&& value);
  #endif
  void set_getobjectbyversionid(const char* value);
  void set_getobjectbyversionid(const char* value, size_t size);
  ::std::string* mutable_getobjectbyversionid();
  ::std::string* release_getobjectbyversionid();
  void set_allocated_getobjectbyversionid(::std::string* getobjectbyversionid);

  // string listdeleteMarker = 16;
  void clear_listdeletemarker();
  static const int kListdeleteMarkerFieldNumber = 16;
  const ::std::string& listdeletemarker() const;
  void set_listdeletemarker(const ::std::string& value);
  #if LANG_CXX11
  void set_listdeletemarker(::std::string&& value);
  #endif
  void set_listdeletemarker(const char* value);
  void set_listdeletemarker(const char* value, size_t size);
  ::std::string* mutable_listdeletemarker();
  ::std::string* release_listdeletemarker();
  void set_allocated_listdeletemarker(::std::string* listdeletemarker);

  // string markerId = 17;
  void clear_markerid();
  static const int kMarkerIdFieldNumber = 17;
  const ::std::string& markerid() const;
  void set_markerid(const ::std::string& value);
  #if LANG_CXX11
  void set_markerid(::std::string&& value);
  #endif
  void set_markerid(const char* value);
  void set_markerid(const char* value, size_t size);
  ::std::string* mutable_markerid();
  ::std::string* release_markerid();
  void set_allocated_markerid(::std::string* markerid);

  // string filecount = 18;
  void clear_filecount();
  static const int kFilecountFieldNumber = 18;
  const ::std::string& filecount() const;
  void set_filecount(const ::std::string& value);
  #if LANG_CXX11
  void set_filecount(::std::string&& value);
  #endif
  void set_filecount(const char* value);
  void set_filecount(const char* value, size_t size);
  ::std::string* mutable_filecount();
  ::std::string* release_filecount();
  void set_allocated_filecount(::std::string* filecount);

  // string filename = 19;
  void clear_filename();
  static const int kFilenameFieldNumber = 19;
  const ::std::string& filename() const;
  void set_filename(const ::std::string& value);
  #if LANG_CXX11
  void set_filename(::std::string&& value);
  #endif
  void set_filename(const char* value);
  void set_filename(const char* value, size_t size);
  ::std::string* mutable_filename();
  ::std::string* release_filename();
  void set_allocated_filename(::std::string* filename);

  // string filesize = 20;
  void clear_filesize();
  static const int kFilesizeFieldNumber = 20;
  const ::std::string& filesize() const;
  void set_filesize(const ::std::string& value);
  #if LANG_CXX11
  void set_filesize(::std::string&& value);
  #endif
  void set_filesize(const char* value);
  void set_filesize(const char* value, size_t size);
  ::std::string* mutable_filesize();
  ::std::string* release_filesize();
  void set_allocated_filesize(::std::string* filesize);

  // string file = 21;
  void clear_file();
  static const int kFileFieldNumber = 21;
  const ::std::string& file() const;
  void set_file(const ::std::string& value);
  #if LANG_CXX11
  void set_file(::std::string&& value);
  #endif
  void set_file(const char* value);
  void set_file(const char* value, size_t size);
  ::std::string* mutable_file();
  ::std::string* release_file();
  void set_allocated_file(::std::string* file);

  // string retention_duration = 23;
  void clear_retention_duration();
  static const int kRetentionDurationFieldNumber = 23;
  const ::std::string& retention_duration() const;
  void set_retention_duration(const ::std::string& value);
  #if LANG_CXX11
  void set_retention_duration(::std::string&& value);
  #endif
  void set_retention_duration(const char* value);
  void set_retention_duration(const char* value, size_t size);
  ::std::string* mutable_retention_duration();
  ::std::string* release_retention_duration();
  void set_allocated_retention_duration(::std::string* retention_duration);

  // .s3service.s3object.objectOperation objectOp = 1;
  void clear_objectop();
  static const int kObjectOpFieldNumber = 1;
  ::s3service::s3object_objectOperation objectop() const;
  void set_objectop(::s3service::s3object_objectOperation value);

  // int32 len = 6;
  void clear_len();
  static const int kLenFieldNumber = 6;
  ::google::protobuf::int32 len() const;
  void set_len(::google::protobuf::int32 value);

  // bool locking = 22;
  void clear_locking();
  static const int kLockingFieldNumber = 22;
  bool locking() const;
  void set_locking(bool value);

  // @@protoc_insertion_point(class_scope:s3service.s3object)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::s3service::s3authorization > auth_;
  ::google::protobuf::RepeatedPtrField< ::s3service::errorDetails > errorinfo_;
  ::google::protobuf::RepeatedPtrField< ::std::string> multipartlist_;
  ::google::protobuf::internal::ArenaStringPtr bucketname_;
  ::google::protobuf::internal::ArenaStringPtr objectname_;
  ::google::protobuf::internal::ArenaStringPtr objectpath_;
  ::google::protobuf::internal::ArenaStringPtr tag_;
  ::google::protobuf::internal::ArenaStringPtr putid_;
  ::google::protobuf::internal::ArenaStringPtr versionid_;
  ::google::protobuf::internal::ArenaStringPtr multipartno_;
  ::google::protobuf::internal::ArenaStringPtr multipartuniqueid_;
  ::google::protobuf::internal::ArenaStringPtr list_object_;
  ::google::protobuf::internal::ArenaStringPtr getobjectbyversionid_;
  ::google::protobuf::internal::ArenaStringPtr listdeletemarker_;
  ::google::protobuf::internal::ArenaStringPtr markerid_;
  ::google::protobuf::internal::ArenaStringPtr filecount_;
  ::google::protobuf::internal::ArenaStringPtr filename_;
  ::google::protobuf::internal::ArenaStringPtr filesize_;
  ::google::protobuf::internal::ArenaStringPtr file_;
  ::google::protobuf::internal::ArenaStringPtr retention_duration_;
  int objectop_;
  ::google::protobuf::int32 len_;
  bool locking_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_s3service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class S3server : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:s3service.S3server) */ {
 public:
  S3server();
  virtual ~S3server();

  S3server(const S3server& from);

  inline S3server& operator=(const S3server& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  S3server(S3server&& from) noexcept
    : S3server() {
    *this = ::std::move(from);
  }

  inline S3server& operator=(S3server&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const S3server& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const S3server* internal_default_instance() {
    return reinterpret_cast<const S3server*>(
               &_S3server_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(S3server* other);
  friend void swap(S3server& a, S3server& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline S3server* New() const final {
    return CreateMaybeMessage<S3server>(NULL);
  }

  S3server* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<S3server>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const S3server& from);
  void MergeFrom(const S3server& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S3server* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef S3server_serveroperation serveroperation;
  static const serveroperation Serverdown =
    S3server_serveroperation_Serverdown;
  static inline bool serveroperation_IsValid(int value) {
    return S3server_serveroperation_IsValid(value);
  }
  static const serveroperation serveroperation_MIN =
    S3server_serveroperation_serveroperation_MIN;
  static const serveroperation serveroperation_MAX =
    S3server_serveroperation_serveroperation_MAX;
  static const int serveroperation_ARRAYSIZE =
    S3server_serveroperation_serveroperation_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  serveroperation_descriptor() {
    return S3server_serveroperation_descriptor();
  }
  static inline const ::std::string& serveroperation_Name(serveroperation value) {
    return S3server_serveroperation_Name(value);
  }
  static inline bool serveroperation_Parse(const ::std::string& name,
      serveroperation* value) {
    return S3server_serveroperation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .s3service.s3authorization auth = 2;
  int auth_size() const;
  void clear_auth();
  static const int kAuthFieldNumber = 2;
  ::s3service::s3authorization* mutable_auth(int index);
  ::google::protobuf::RepeatedPtrField< ::s3service::s3authorization >*
      mutable_auth();
  const ::s3service::s3authorization& auth(int index) const;
  ::s3service::s3authorization* add_auth();
  const ::google::protobuf::RepeatedPtrField< ::s3service::s3authorization >&
      auth() const;

  // repeated .s3service.errorDetails errorInfo = 3;
  int errorinfo_size() const;
  void clear_errorinfo();
  static const int kErrorInfoFieldNumber = 3;
  ::s3service::errorDetails* mutable_errorinfo(int index);
  ::google::protobuf::RepeatedPtrField< ::s3service::errorDetails >*
      mutable_errorinfo();
  const ::s3service::errorDetails& errorinfo(int index) const;
  ::s3service::errorDetails* add_errorinfo();
  const ::google::protobuf::RepeatedPtrField< ::s3service::errorDetails >&
      errorinfo() const;

  // string serverMessage = 4;
  void clear_servermessage();
  static const int kServerMessageFieldNumber = 4;
  const ::std::string& servermessage() const;
  void set_servermessage(const ::std::string& value);
  #if LANG_CXX11
  void set_servermessage(::std::string&& value);
  #endif
  void set_servermessage(const char* value);
  void set_servermessage(const char* value, size_t size);
  ::std::string* mutable_servermessage();
  ::std::string* release_servermessage();
  void set_allocated_servermessage(::std::string* servermessage);

  // .s3service.S3server.serveroperation serverOp = 1;
  void clear_serverop();
  static const int kServerOpFieldNumber = 1;
  ::s3service::S3server_serveroperation serverop() const;
  void set_serverop(::s3service::S3server_serveroperation value);

  // @@protoc_insertion_point(class_scope:s3service.S3server)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::s3service::s3authorization > auth_;
  ::google::protobuf::RepeatedPtrField< ::s3service::errorDetails > errorinfo_;
  ::google::protobuf::internal::ArenaStringPtr servermessage_;
  int serverop_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_s3service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class serviceRequestResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:s3service.serviceRequestResponse) */ {
 public:
  serviceRequestResponse();
  virtual ~serviceRequestResponse();

  serviceRequestResponse(const serviceRequestResponse& from);

  inline serviceRequestResponse& operator=(const serviceRequestResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  serviceRequestResponse(serviceRequestResponse&& from) noexcept
    : serviceRequestResponse() {
    *this = ::std::move(from);
  }

  inline serviceRequestResponse& operator=(serviceRequestResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const serviceRequestResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const serviceRequestResponse* internal_default_instance() {
    return reinterpret_cast<const serviceRequestResponse*>(
               &_serviceRequestResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(serviceRequestResponse* other);
  friend void swap(serviceRequestResponse& a, serviceRequestResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline serviceRequestResponse* New() const final {
    return CreateMaybeMessage<serviceRequestResponse>(NULL);
  }

  serviceRequestResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<serviceRequestResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const serviceRequestResponse& from);
  void MergeFrom(const serviceRequestResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(serviceRequestResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef serviceRequestResponse_serviceEntity serviceEntity;
  static const serviceEntity USER =
    serviceRequestResponse_serviceEntity_USER;
  static const serviceEntity ACCOUNT =
    serviceRequestResponse_serviceEntity_ACCOUNT;
  static const serviceEntity BUCKET =
    serviceRequestResponse_serviceEntity_BUCKET;
  static const serviceEntity OBJECT =
    serviceRequestResponse_serviceEntity_OBJECT;
  static const serviceEntity LOCATION =
    serviceRequestResponse_serviceEntity_LOCATION;
  static const serviceEntity ACCESSKEY =
    serviceRequestResponse_serviceEntity_ACCESSKEY;
  static const serviceEntity SERVER =
    serviceRequestResponse_serviceEntity_SERVER;
  static inline bool serviceEntity_IsValid(int value) {
    return serviceRequestResponse_serviceEntity_IsValid(value);
  }
  static const serviceEntity serviceEntity_MIN =
    serviceRequestResponse_serviceEntity_serviceEntity_MIN;
  static const serviceEntity serviceEntity_MAX =
    serviceRequestResponse_serviceEntity_serviceEntity_MAX;
  static const int serviceEntity_ARRAYSIZE =
    serviceRequestResponse_serviceEntity_serviceEntity_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  serviceEntity_descriptor() {
    return serviceRequestResponse_serviceEntity_descriptor();
  }
  static inline const ::std::string& serviceEntity_Name(serviceEntity value) {
    return serviceRequestResponse_serviceEntity_Name(value);
  }
  static inline bool serviceEntity_Parse(const ::std::string& name,
      serviceEntity* value) {
    return serviceRequestResponse_serviceEntity_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .s3service.s3user user = 3;
  int user_size() const;
  void clear_user();
  static const int kUserFieldNumber = 3;
  ::s3service::s3user* mutable_user(int index);
  ::google::protobuf::RepeatedPtrField< ::s3service::s3user >*
      mutable_user();
  const ::s3service::s3user& user(int index) const;
  ::s3service::s3user* add_user();
  const ::google::protobuf::RepeatedPtrField< ::s3service::s3user >&
      user() const;

  // repeated .s3service.s3account account = 4;
  int account_size() const;
  void clear_account();
  static const int kAccountFieldNumber = 4;
  ::s3service::s3account* mutable_account(int index);
  ::google::protobuf::RepeatedPtrField< ::s3service::s3account >*
      mutable_account();
  const ::s3service::s3account& account(int index) const;
  ::s3service::s3account* add_account();
  const ::google::protobuf::RepeatedPtrField< ::s3service::s3account >&
      account() const;

  // repeated .s3service.s3bucket bucket = 5;
  int bucket_size() const;
  void clear_bucket();
  static const int kBucketFieldNumber = 5;
  ::s3service::s3bucket* mutable_bucket(int index);
  ::google::protobuf::RepeatedPtrField< ::s3service::s3bucket >*
      mutable_bucket();
  const ::s3service::s3bucket& bucket(int index) const;
  ::s3service::s3bucket* add_bucket();
  const ::google::protobuf::RepeatedPtrField< ::s3service::s3bucket >&
      bucket() const;

  // repeated .s3service.s3object object = 6;
  int object_size() const;
  void clear_object();
  static const int kObjectFieldNumber = 6;
  ::s3service::s3object* mutable_object(int index);
  ::google::protobuf::RepeatedPtrField< ::s3service::s3object >*
      mutable_object();
  const ::s3service::s3object& object(int index) const;
  ::s3service::s3object* add_object();
  const ::google::protobuf::RepeatedPtrField< ::s3service::s3object >&
      object() const;

  // repeated .s3service.s3accesskey accesskey = 7;
  int accesskey_size() const;
  void clear_accesskey();
  static const int kAccesskeyFieldNumber = 7;
  ::s3service::s3accesskey* mutable_accesskey(int index);
  ::google::protobuf::RepeatedPtrField< ::s3service::s3accesskey >*
      mutable_accesskey();
  const ::s3service::s3accesskey& accesskey(int index) const;
  ::s3service::s3accesskey* add_accesskey();
  const ::google::protobuf::RepeatedPtrField< ::s3service::s3accesskey >&
      accesskey() const;

  // repeated .s3service.S3server server = 8;
  int server_size() const;
  void clear_server();
  static const int kServerFieldNumber = 8;
  ::s3service::S3server* mutable_server(int index);
  ::google::protobuf::RepeatedPtrField< ::s3service::S3server >*
      mutable_server();
  const ::s3service::S3server& server(int index) const;
  ::s3service::S3server* add_server();
  const ::google::protobuf::RepeatedPtrField< ::s3service::S3server >&
      server() const;

  // string requestId = 2;
  void clear_requestid();
  static const int kRequestIdFieldNumber = 2;
  const ::std::string& requestid() const;
  void set_requestid(const ::std::string& value);
  #if LANG_CXX11
  void set_requestid(::std::string&& value);
  #endif
  void set_requestid(const char* value);
  void set_requestid(const char* value, size_t size);
  ::std::string* mutable_requestid();
  ::std::string* release_requestid();
  void set_allocated_requestid(::std::string* requestid);

  // .s3service.serviceRequestResponse.serviceEntity entityType = 1;
  void clear_entitytype();
  static const int kEntityTypeFieldNumber = 1;
  ::s3service::serviceRequestResponse_serviceEntity entitytype() const;
  void set_entitytype(::s3service::serviceRequestResponse_serviceEntity value);

  // @@protoc_insertion_point(class_scope:s3service.serviceRequestResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::s3service::s3user > user_;
  ::google::protobuf::RepeatedPtrField< ::s3service::s3account > account_;
  ::google::protobuf::RepeatedPtrField< ::s3service::s3bucket > bucket_;
  ::google::protobuf::RepeatedPtrField< ::s3service::s3object > object_;
  ::google::protobuf::RepeatedPtrField< ::s3service::s3accesskey > accesskey_;
  ::google::protobuf::RepeatedPtrField< ::s3service::S3server > server_;
  ::google::protobuf::internal::ArenaStringPtr requestid_;
  int entitytype_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_s3service_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// s3authorization

// string accessKey = 1;
inline void s3authorization::clear_accesskey() {
  accesskey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& s3authorization::accesskey() const {
  // @@protoc_insertion_point(field_get:s3service.s3authorization.accessKey)
  return accesskey_.GetNoArena();
}
inline void s3authorization::set_accesskey(const ::std::string& value) {
  
  accesskey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.s3authorization.accessKey)
}
#if LANG_CXX11
inline void s3authorization::set_accesskey(::std::string&& value) {
  
  accesskey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.s3authorization.accessKey)
}
#endif
inline void s3authorization::set_accesskey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  accesskey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.s3authorization.accessKey)
}
inline void s3authorization::set_accesskey(const char* value, size_t size) {
  
  accesskey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.s3authorization.accessKey)
}
inline ::std::string* s3authorization::mutable_accesskey() {
  
  // @@protoc_insertion_point(field_mutable:s3service.s3authorization.accessKey)
  return accesskey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* s3authorization::release_accesskey() {
  // @@protoc_insertion_point(field_release:s3service.s3authorization.accessKey)
  
  return accesskey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void s3authorization::set_allocated_accesskey(::std::string* accesskey) {
  if (accesskey != NULL) {
    
  } else {
    
  }
  accesskey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), accesskey);
  // @@protoc_insertion_point(field_set_allocated:s3service.s3authorization.accessKey)
}

// string secretKey = 2;
inline void s3authorization::clear_secretkey() {
  secretkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& s3authorization::secretkey() const {
  // @@protoc_insertion_point(field_get:s3service.s3authorization.secretKey)
  return secretkey_.GetNoArena();
}
inline void s3authorization::set_secretkey(const ::std::string& value) {
  
  secretkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.s3authorization.secretKey)
}
#if LANG_CXX11
inline void s3authorization::set_secretkey(::std::string&& value) {
  
  secretkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.s3authorization.secretKey)
}
#endif
inline void s3authorization::set_secretkey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  secretkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.s3authorization.secretKey)
}
inline void s3authorization::set_secretkey(const char* value, size_t size) {
  
  secretkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.s3authorization.secretKey)
}
inline ::std::string* s3authorization::mutable_secretkey() {
  
  // @@protoc_insertion_point(field_mutable:s3service.s3authorization.secretKey)
  return secretkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* s3authorization::release_secretkey() {
  // @@protoc_insertion_point(field_release:s3service.s3authorization.secretKey)
  
  return secretkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void s3authorization::set_allocated_secretkey(::std::string* secretkey) {
  if (secretkey != NULL) {
    
  } else {
    
  }
  secretkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), secretkey);
  // @@protoc_insertion_point(field_set_allocated:s3service.s3authorization.secretKey)
}

// -------------------------------------------------------------------

// errorDetails

// string errorMessage = 1;
inline void errorDetails::clear_errormessage() {
  errormessage_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& errorDetails::errormessage() const {
  // @@protoc_insertion_point(field_get:s3service.errorDetails.errorMessage)
  return errormessage_.GetNoArena();
}
inline void errorDetails::set_errormessage(const ::std::string& value) {
  
  errormessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.errorDetails.errorMessage)
}
#if LANG_CXX11
inline void errorDetails::set_errormessage(::std::string&& value) {
  
  errormessage_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.errorDetails.errorMessage)
}
#endif
inline void errorDetails::set_errormessage(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  errormessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.errorDetails.errorMessage)
}
inline void errorDetails::set_errormessage(const char* value, size_t size) {
  
  errormessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.errorDetails.errorMessage)
}
inline ::std::string* errorDetails::mutable_errormessage() {
  
  // @@protoc_insertion_point(field_mutable:s3service.errorDetails.errorMessage)
  return errormessage_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* errorDetails::release_errormessage() {
  // @@protoc_insertion_point(field_release:s3service.errorDetails.errorMessage)
  
  return errormessage_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void errorDetails::set_allocated_errormessage(::std::string* errormessage) {
  if (errormessage != NULL) {
    
  } else {
    
  }
  errormessage_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), errormessage);
  // @@protoc_insertion_point(field_set_allocated:s3service.errorDetails.errorMessage)
}

// string errorType = 2;
inline void errorDetails::clear_errortype() {
  errortype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& errorDetails::errortype() const {
  // @@protoc_insertion_point(field_get:s3service.errorDetails.errorType)
  return errortype_.GetNoArena();
}
inline void errorDetails::set_errortype(const ::std::string& value) {
  
  errortype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.errorDetails.errorType)
}
#if LANG_CXX11
inline void errorDetails::set_errortype(::std::string&& value) {
  
  errortype_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.errorDetails.errorType)
}
#endif
inline void errorDetails::set_errortype(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  errortype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.errorDetails.errorType)
}
inline void errorDetails::set_errortype(const char* value, size_t size) {
  
  errortype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.errorDetails.errorType)
}
inline ::std::string* errorDetails::mutable_errortype() {
  
  // @@protoc_insertion_point(field_mutable:s3service.errorDetails.errorType)
  return errortype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* errorDetails::release_errortype() {
  // @@protoc_insertion_point(field_release:s3service.errorDetails.errorType)
  
  return errortype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void errorDetails::set_allocated_errortype(::std::string* errortype) {
  if (errortype != NULL) {
    
  } else {
    
  }
  errortype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), errortype);
  // @@protoc_insertion_point(field_set_allocated:s3service.errorDetails.errorType)
}

// string errorCode = 3;
inline void errorDetails::clear_errorcode() {
  errorcode_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& errorDetails::errorcode() const {
  // @@protoc_insertion_point(field_get:s3service.errorDetails.errorCode)
  return errorcode_.GetNoArena();
}
inline void errorDetails::set_errorcode(const ::std::string& value) {
  
  errorcode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.errorDetails.errorCode)
}
#if LANG_CXX11
inline void errorDetails::set_errorcode(::std::string&& value) {
  
  errorcode_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.errorDetails.errorCode)
}
#endif
inline void errorDetails::set_errorcode(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  errorcode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.errorDetails.errorCode)
}
inline void errorDetails::set_errorcode(const char* value, size_t size) {
  
  errorcode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.errorDetails.errorCode)
}
inline ::std::string* errorDetails::mutable_errorcode() {
  
  // @@protoc_insertion_point(field_mutable:s3service.errorDetails.errorCode)
  return errorcode_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* errorDetails::release_errorcode() {
  // @@protoc_insertion_point(field_release:s3service.errorDetails.errorCode)
  
  return errorcode_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void errorDetails::set_allocated_errorcode(::std::string* errorcode) {
  if (errorcode != NULL) {
    
  } else {
    
  }
  errorcode_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), errorcode);
  // @@protoc_insertion_point(field_set_allocated:s3service.errorDetails.errorCode)
}

// string hostId = 4;
inline void errorDetails::clear_hostid() {
  hostid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& errorDetails::hostid() const {
  // @@protoc_insertion_point(field_get:s3service.errorDetails.hostId)
  return hostid_.GetNoArena();
}
inline void errorDetails::set_hostid(const ::std::string& value) {
  
  hostid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.errorDetails.hostId)
}
#if LANG_CXX11
inline void errorDetails::set_hostid(::std::string&& value) {
  
  hostid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.errorDetails.hostId)
}
#endif
inline void errorDetails::set_hostid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hostid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.errorDetails.hostId)
}
inline void errorDetails::set_hostid(const char* value, size_t size) {
  
  hostid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.errorDetails.hostId)
}
inline ::std::string* errorDetails::mutable_hostid() {
  
  // @@protoc_insertion_point(field_mutable:s3service.errorDetails.hostId)
  return hostid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* errorDetails::release_hostid() {
  // @@protoc_insertion_point(field_release:s3service.errorDetails.hostId)
  
  return hostid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void errorDetails::set_allocated_hostid(::std::string* hostid) {
  if (hostid != NULL) {
    
  } else {
    
  }
  hostid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hostid);
  // @@protoc_insertion_point(field_set_allocated:s3service.errorDetails.hostId)
}

// string methodType = 5;
inline void errorDetails::clear_methodtype() {
  methodtype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& errorDetails::methodtype() const {
  // @@protoc_insertion_point(field_get:s3service.errorDetails.methodType)
  return methodtype_.GetNoArena();
}
inline void errorDetails::set_methodtype(const ::std::string& value) {
  
  methodtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.errorDetails.methodType)
}
#if LANG_CXX11
inline void errorDetails::set_methodtype(::std::string&& value) {
  
  methodtype_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.errorDetails.methodType)
}
#endif
inline void errorDetails::set_methodtype(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  methodtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.errorDetails.methodType)
}
inline void errorDetails::set_methodtype(const char* value, size_t size) {
  
  methodtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.errorDetails.methodType)
}
inline ::std::string* errorDetails::mutable_methodtype() {
  
  // @@protoc_insertion_point(field_mutable:s3service.errorDetails.methodType)
  return methodtype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* errorDetails::release_methodtype() {
  // @@protoc_insertion_point(field_release:s3service.errorDetails.methodType)
  
  return methodtype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void errorDetails::set_allocated_methodtype(::std::string* methodtype) {
  if (methodtype != NULL) {
    
  } else {
    
  }
  methodtype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), methodtype);
  // @@protoc_insertion_point(field_set_allocated:s3service.errorDetails.methodType)
}

// string resourceType = 6;
inline void errorDetails::clear_resourcetype() {
  resourcetype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& errorDetails::resourcetype() const {
  // @@protoc_insertion_point(field_get:s3service.errorDetails.resourceType)
  return resourcetype_.GetNoArena();
}
inline void errorDetails::set_resourcetype(const ::std::string& value) {
  
  resourcetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.errorDetails.resourceType)
}
#if LANG_CXX11
inline void errorDetails::set_resourcetype(::std::string&& value) {
  
  resourcetype_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.errorDetails.resourceType)
}
#endif
inline void errorDetails::set_resourcetype(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  resourcetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.errorDetails.resourceType)
}
inline void errorDetails::set_resourcetype(const char* value, size_t size) {
  
  resourcetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.errorDetails.resourceType)
}
inline ::std::string* errorDetails::mutable_resourcetype() {
  
  // @@protoc_insertion_point(field_mutable:s3service.errorDetails.resourceType)
  return resourcetype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* errorDetails::release_resourcetype() {
  // @@protoc_insertion_point(field_release:s3service.errorDetails.resourceType)
  
  return resourcetype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void errorDetails::set_allocated_resourcetype(::std::string* resourcetype) {
  if (resourcetype != NULL) {
    
  } else {
    
  }
  resourcetype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), resourcetype);
  // @@protoc_insertion_point(field_set_allocated:s3service.errorDetails.resourceType)
}

// string key = 7;
inline void errorDetails::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& errorDetails::key() const {
  // @@protoc_insertion_point(field_get:s3service.errorDetails.key)
  return key_.GetNoArena();
}
inline void errorDetails::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.errorDetails.key)
}
#if LANG_CXX11
inline void errorDetails::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.errorDetails.key)
}
#endif
inline void errorDetails::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.errorDetails.key)
}
inline void errorDetails::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.errorDetails.key)
}
inline ::std::string* errorDetails::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:s3service.errorDetails.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* errorDetails::release_key() {
  // @@protoc_insertion_point(field_release:s3service.errorDetails.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void errorDetails::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:s3service.errorDetails.key)
}

// -------------------------------------------------------------------

// s3accesskey

// .s3service.s3accesskey.accesskeyOperation accessOp = 1;
inline void s3accesskey::clear_accessop() {
  accessop_ = 0;
}
inline ::s3service::s3accesskey_accesskeyOperation s3accesskey::accessop() const {
  // @@protoc_insertion_point(field_get:s3service.s3accesskey.accessOp)
  return static_cast< ::s3service::s3accesskey_accesskeyOperation >(accessop_);
}
inline void s3accesskey::set_accessop(::s3service::s3accesskey_accesskeyOperation value) {
  
  accessop_ = value;
  // @@protoc_insertion_point(field_set:s3service.s3accesskey.accessOp)
}

// repeated .s3service.s3authorization auth = 2;
inline int s3accesskey::auth_size() const {
  return auth_.size();
}
inline void s3accesskey::clear_auth() {
  auth_.Clear();
}
inline ::s3service::s3authorization* s3accesskey::mutable_auth(int index) {
  // @@protoc_insertion_point(field_mutable:s3service.s3accesskey.auth)
  return auth_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::s3service::s3authorization >*
s3accesskey::mutable_auth() {
  // @@protoc_insertion_point(field_mutable_list:s3service.s3accesskey.auth)
  return &auth_;
}
inline const ::s3service::s3authorization& s3accesskey::auth(int index) const {
  // @@protoc_insertion_point(field_get:s3service.s3accesskey.auth)
  return auth_.Get(index);
}
inline ::s3service::s3authorization* s3accesskey::add_auth() {
  // @@protoc_insertion_point(field_add:s3service.s3accesskey.auth)
  return auth_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::s3service::s3authorization >&
s3accesskey::auth() const {
  // @@protoc_insertion_point(field_list:s3service.s3accesskey.auth)
  return auth_;
}

// string accessKeyId = 3;
inline void s3accesskey::clear_accesskeyid() {
  accesskeyid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& s3accesskey::accesskeyid() const {
  // @@protoc_insertion_point(field_get:s3service.s3accesskey.accessKeyId)
  return accesskeyid_.GetNoArena();
}
inline void s3accesskey::set_accesskeyid(const ::std::string& value) {
  
  accesskeyid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.s3accesskey.accessKeyId)
}
#if LANG_CXX11
inline void s3accesskey::set_accesskeyid(::std::string&& value) {
  
  accesskeyid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.s3accesskey.accessKeyId)
}
#endif
inline void s3accesskey::set_accesskeyid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  accesskeyid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.s3accesskey.accessKeyId)
}
inline void s3accesskey::set_accesskeyid(const char* value, size_t size) {
  
  accesskeyid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.s3accesskey.accessKeyId)
}
inline ::std::string* s3accesskey::mutable_accesskeyid() {
  
  // @@protoc_insertion_point(field_mutable:s3service.s3accesskey.accessKeyId)
  return accesskeyid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* s3accesskey::release_accesskeyid() {
  // @@protoc_insertion_point(field_release:s3service.s3accesskey.accessKeyId)
  
  return accesskeyid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void s3accesskey::set_allocated_accesskeyid(::std::string* accesskeyid) {
  if (accesskeyid != NULL) {
    
  } else {
    
  }
  accesskeyid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), accesskeyid);
  // @@protoc_insertion_point(field_set_allocated:s3service.s3accesskey.accessKeyId)
}

// string secretKey = 4;
inline void s3accesskey::clear_secretkey() {
  secretkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& s3accesskey::secretkey() const {
  // @@protoc_insertion_point(field_get:s3service.s3accesskey.secretKey)
  return secretkey_.GetNoArena();
}
inline void s3accesskey::set_secretkey(const ::std::string& value) {
  
  secretkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.s3accesskey.secretKey)
}
#if LANG_CXX11
inline void s3accesskey::set_secretkey(::std::string&& value) {
  
  secretkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.s3accesskey.secretKey)
}
#endif
inline void s3accesskey::set_secretkey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  secretkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.s3accesskey.secretKey)
}
inline void s3accesskey::set_secretkey(const char* value, size_t size) {
  
  secretkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.s3accesskey.secretKey)
}
inline ::std::string* s3accesskey::mutable_secretkey() {
  
  // @@protoc_insertion_point(field_mutable:s3service.s3accesskey.secretKey)
  return secretkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* s3accesskey::release_secretkey() {
  // @@protoc_insertion_point(field_release:s3service.s3accesskey.secretKey)
  
  return secretkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void s3accesskey::set_allocated_secretkey(::std::string* secretkey) {
  if (secretkey != NULL) {
    
  } else {
    
  }
  secretkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), secretkey);
  // @@protoc_insertion_point(field_set_allocated:s3service.s3accesskey.secretKey)
}

// string accessKeySelector = 5;
inline void s3accesskey::clear_accesskeyselector() {
  accesskeyselector_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& s3accesskey::accesskeyselector() const {
  // @@protoc_insertion_point(field_get:s3service.s3accesskey.accessKeySelector)
  return accesskeyselector_.GetNoArena();
}
inline void s3accesskey::set_accesskeyselector(const ::std::string& value) {
  
  accesskeyselector_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.s3accesskey.accessKeySelector)
}
#if LANG_CXX11
inline void s3accesskey::set_accesskeyselector(::std::string&& value) {
  
  accesskeyselector_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.s3accesskey.accessKeySelector)
}
#endif
inline void s3accesskey::set_accesskeyselector(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  accesskeyselector_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.s3accesskey.accessKeySelector)
}
inline void s3accesskey::set_accesskeyselector(const char* value, size_t size) {
  
  accesskeyselector_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.s3accesskey.accessKeySelector)
}
inline ::std::string* s3accesskey::mutable_accesskeyselector() {
  
  // @@protoc_insertion_point(field_mutable:s3service.s3accesskey.accessKeySelector)
  return accesskeyselector_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* s3accesskey::release_accesskeyselector() {
  // @@protoc_insertion_point(field_release:s3service.s3accesskey.accessKeySelector)
  
  return accesskeyselector_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void s3accesskey::set_allocated_accesskeyselector(::std::string* accesskeyselector) {
  if (accesskeyselector != NULL) {
    
  } else {
    
  }
  accesskeyselector_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), accesskeyselector);
  // @@protoc_insertion_point(field_set_allocated:s3service.s3accesskey.accessKeySelector)
}

// string username = 6;
inline void s3accesskey::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& s3accesskey::username() const {
  // @@protoc_insertion_point(field_get:s3service.s3accesskey.username)
  return username_.GetNoArena();
}
inline void s3accesskey::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.s3accesskey.username)
}
#if LANG_CXX11
inline void s3accesskey::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.s3accesskey.username)
}
#endif
inline void s3accesskey::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.s3accesskey.username)
}
inline void s3accesskey::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.s3accesskey.username)
}
inline ::std::string* s3accesskey::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:s3service.s3accesskey.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* s3accesskey::release_username() {
  // @@protoc_insertion_point(field_release:s3service.s3accesskey.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void s3accesskey::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:s3service.s3accesskey.username)
}

// string createDate = 7;
inline void s3accesskey::clear_createdate() {
  createdate_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& s3accesskey::createdate() const {
  // @@protoc_insertion_point(field_get:s3service.s3accesskey.createDate)
  return createdate_.GetNoArena();
}
inline void s3accesskey::set_createdate(const ::std::string& value) {
  
  createdate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.s3accesskey.createDate)
}
#if LANG_CXX11
inline void s3accesskey::set_createdate(::std::string&& value) {
  
  createdate_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.s3accesskey.createDate)
}
#endif
inline void s3accesskey::set_createdate(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  createdate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.s3accesskey.createDate)
}
inline void s3accesskey::set_createdate(const char* value, size_t size) {
  
  createdate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.s3accesskey.createDate)
}
inline ::std::string* s3accesskey::mutable_createdate() {
  
  // @@protoc_insertion_point(field_mutable:s3service.s3accesskey.createDate)
  return createdate_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* s3accesskey::release_createdate() {
  // @@protoc_insertion_point(field_release:s3service.s3accesskey.createDate)
  
  return createdate_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void s3accesskey::set_allocated_createdate(::std::string* createdate) {
  if (createdate != NULL) {
    
  } else {
    
  }
  createdate_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), createdate);
  // @@protoc_insertion_point(field_set_allocated:s3service.s3accesskey.createDate)
}

// string status = 8;
inline void s3accesskey::clear_status() {
  status_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& s3accesskey::status() const {
  // @@protoc_insertion_point(field_get:s3service.s3accesskey.status)
  return status_.GetNoArena();
}
inline void s3accesskey::set_status(const ::std::string& value) {
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.s3accesskey.status)
}
#if LANG_CXX11
inline void s3accesskey::set_status(::std::string&& value) {
  
  status_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.s3accesskey.status)
}
#endif
inline void s3accesskey::set_status(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.s3accesskey.status)
}
inline void s3accesskey::set_status(const char* value, size_t size) {
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.s3accesskey.status)
}
inline ::std::string* s3accesskey::mutable_status() {
  
  // @@protoc_insertion_point(field_mutable:s3service.s3accesskey.status)
  return status_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* s3accesskey::release_status() {
  // @@protoc_insertion_point(field_release:s3service.s3accesskey.status)
  
  return status_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void s3accesskey::set_allocated_status(::std::string* status) {
  if (status != NULL) {
    
  } else {
    
  }
  status_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), status);
  // @@protoc_insertion_point(field_set_allocated:s3service.s3accesskey.status)
}

// string lastUsedDate = 9;
inline void s3accesskey::clear_lastuseddate() {
  lastuseddate_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& s3accesskey::lastuseddate() const {
  // @@protoc_insertion_point(field_get:s3service.s3accesskey.lastUsedDate)
  return lastuseddate_.GetNoArena();
}
inline void s3accesskey::set_lastuseddate(const ::std::string& value) {
  
  lastuseddate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.s3accesskey.lastUsedDate)
}
#if LANG_CXX11
inline void s3accesskey::set_lastuseddate(::std::string&& value) {
  
  lastuseddate_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.s3accesskey.lastUsedDate)
}
#endif
inline void s3accesskey::set_lastuseddate(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  lastuseddate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.s3accesskey.lastUsedDate)
}
inline void s3accesskey::set_lastuseddate(const char* value, size_t size) {
  
  lastuseddate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.s3accesskey.lastUsedDate)
}
inline ::std::string* s3accesskey::mutable_lastuseddate() {
  
  // @@protoc_insertion_point(field_mutable:s3service.s3accesskey.lastUsedDate)
  return lastuseddate_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* s3accesskey::release_lastuseddate() {
  // @@protoc_insertion_point(field_release:s3service.s3accesskey.lastUsedDate)
  
  return lastuseddate_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void s3accesskey::set_allocated_lastuseddate(::std::string* lastuseddate) {
  if (lastuseddate != NULL) {
    
  } else {
    
  }
  lastuseddate_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lastuseddate);
  // @@protoc_insertion_point(field_set_allocated:s3service.s3accesskey.lastUsedDate)
}

// string ServiceName = 10;
inline void s3accesskey::clear_servicename() {
  servicename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& s3accesskey::servicename() const {
  // @@protoc_insertion_point(field_get:s3service.s3accesskey.ServiceName)
  return servicename_.GetNoArena();
}
inline void s3accesskey::set_servicename(const ::std::string& value) {
  
  servicename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.s3accesskey.ServiceName)
}
#if LANG_CXX11
inline void s3accesskey::set_servicename(::std::string&& value) {
  
  servicename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.s3accesskey.ServiceName)
}
#endif
inline void s3accesskey::set_servicename(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  servicename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.s3accesskey.ServiceName)
}
inline void s3accesskey::set_servicename(const char* value, size_t size) {
  
  servicename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.s3accesskey.ServiceName)
}
inline ::std::string* s3accesskey::mutable_servicename() {
  
  // @@protoc_insertion_point(field_mutable:s3service.s3accesskey.ServiceName)
  return servicename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* s3accesskey::release_servicename() {
  // @@protoc_insertion_point(field_release:s3service.s3accesskey.ServiceName)
  
  return servicename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void s3accesskey::set_allocated_servicename(::std::string* servicename) {
  if (servicename != NULL) {
    
  } else {
    
  }
  servicename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), servicename);
  // @@protoc_insertion_point(field_set_allocated:s3service.s3accesskey.ServiceName)
}

// string Region = 11;
inline void s3accesskey::clear_region() {
  region_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& s3accesskey::region() const {
  // @@protoc_insertion_point(field_get:s3service.s3accesskey.Region)
  return region_.GetNoArena();
}
inline void s3accesskey::set_region(const ::std::string& value) {
  
  region_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.s3accesskey.Region)
}
#if LANG_CXX11
inline void s3accesskey::set_region(::std::string&& value) {
  
  region_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.s3accesskey.Region)
}
#endif
inline void s3accesskey::set_region(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  region_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.s3accesskey.Region)
}
inline void s3accesskey::set_region(const char* value, size_t size) {
  
  region_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.s3accesskey.Region)
}
inline ::std::string* s3accesskey::mutable_region() {
  
  // @@protoc_insertion_point(field_mutable:s3service.s3accesskey.Region)
  return region_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* s3accesskey::release_region() {
  // @@protoc_insertion_point(field_release:s3service.s3accesskey.Region)
  
  return region_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void s3accesskey::set_allocated_region(::std::string* region) {
  if (region != NULL) {
    
  } else {
    
  }
  region_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), region);
  // @@protoc_insertion_point(field_set_allocated:s3service.s3accesskey.Region)
}

// repeated .s3service.errorDetails errorInfo = 12;
inline int s3accesskey::errorinfo_size() const {
  return errorinfo_.size();
}
inline void s3accesskey::clear_errorinfo() {
  errorinfo_.Clear();
}
inline ::s3service::errorDetails* s3accesskey::mutable_errorinfo(int index) {
  // @@protoc_insertion_point(field_mutable:s3service.s3accesskey.errorInfo)
  return errorinfo_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::s3service::errorDetails >*
s3accesskey::mutable_errorinfo() {
  // @@protoc_insertion_point(field_mutable_list:s3service.s3accesskey.errorInfo)
  return &errorinfo_;
}
inline const ::s3service::errorDetails& s3accesskey::errorinfo(int index) const {
  // @@protoc_insertion_point(field_get:s3service.s3accesskey.errorInfo)
  return errorinfo_.Get(index);
}
inline ::s3service::errorDetails* s3accesskey::add_errorinfo() {
  // @@protoc_insertion_point(field_add:s3service.s3accesskey.errorInfo)
  return errorinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::s3service::errorDetails >&
s3accesskey::errorinfo() const {
  // @@protoc_insertion_point(field_list:s3service.s3accesskey.errorInfo)
  return errorinfo_;
}

// -------------------------------------------------------------------

// s3account

// .s3service.s3account.accountOperation accOp = 1;
inline void s3account::clear_accop() {
  accop_ = 0;
}
inline ::s3service::s3account_accountOperation s3account::accop() const {
  // @@protoc_insertion_point(field_get:s3service.s3account.accOp)
  return static_cast< ::s3service::s3account_accountOperation >(accop_);
}
inline void s3account::set_accop(::s3service::s3account_accountOperation value) {
  
  accop_ = value;
  // @@protoc_insertion_point(field_set:s3service.s3account.accOp)
}

// string accountname = 2;
inline void s3account::clear_accountname() {
  accountname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& s3account::accountname() const {
  // @@protoc_insertion_point(field_get:s3service.s3account.accountname)
  return accountname_.GetNoArena();
}
inline void s3account::set_accountname(const ::std::string& value) {
  
  accountname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.s3account.accountname)
}
#if LANG_CXX11
inline void s3account::set_accountname(::std::string&& value) {
  
  accountname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.s3account.accountname)
}
#endif
inline void s3account::set_accountname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  accountname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.s3account.accountname)
}
inline void s3account::set_accountname(const char* value, size_t size) {
  
  accountname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.s3account.accountname)
}
inline ::std::string* s3account::mutable_accountname() {
  
  // @@protoc_insertion_point(field_mutable:s3service.s3account.accountname)
  return accountname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* s3account::release_accountname() {
  // @@protoc_insertion_point(field_release:s3service.s3account.accountname)
  
  return accountname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void s3account::set_allocated_accountname(::std::string* accountname) {
  if (accountname != NULL) {
    
  } else {
    
  }
  accountname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), accountname);
  // @@protoc_insertion_point(field_set_allocated:s3service.s3account.accountname)
}

// string password = 3;
inline void s3account::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& s3account::password() const {
  // @@protoc_insertion_point(field_get:s3service.s3account.password)
  return password_.GetNoArena();
}
inline void s3account::set_password(const ::std::string& value) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.s3account.password)
}
#if LANG_CXX11
inline void s3account::set_password(::std::string&& value) {
  
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.s3account.password)
}
#endif
inline void s3account::set_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.s3account.password)
}
inline void s3account::set_password(const char* value, size_t size) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.s3account.password)
}
inline ::std::string* s3account::mutable_password() {
  
  // @@protoc_insertion_point(field_mutable:s3service.s3account.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* s3account::release_password() {
  // @@protoc_insertion_point(field_release:s3service.s3account.password)
  
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void s3account::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    
  } else {
    
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:s3service.s3account.password)
}

// string accountId = 4;
inline void s3account::clear_accountid() {
  accountid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& s3account::accountid() const {
  // @@protoc_insertion_point(field_get:s3service.s3account.accountId)
  return accountid_.GetNoArena();
}
inline void s3account::set_accountid(const ::std::string& value) {
  
  accountid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.s3account.accountId)
}
#if LANG_CXX11
inline void s3account::set_accountid(::std::string&& value) {
  
  accountid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.s3account.accountId)
}
#endif
inline void s3account::set_accountid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  accountid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.s3account.accountId)
}
inline void s3account::set_accountid(const char* value, size_t size) {
  
  accountid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.s3account.accountId)
}
inline ::std::string* s3account::mutable_accountid() {
  
  // @@protoc_insertion_point(field_mutable:s3service.s3account.accountId)
  return accountid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* s3account::release_accountid() {
  // @@protoc_insertion_point(field_release:s3service.s3account.accountId)
  
  return accountid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void s3account::set_allocated_accountid(::std::string* accountid) {
  if (accountid != NULL) {
    
  } else {
    
  }
  accountid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), accountid);
  // @@protoc_insertion_point(field_set_allocated:s3service.s3account.accountId)
}

// repeated .s3service.s3accesskey keys = 5;
inline int s3account::keys_size() const {
  return keys_.size();
}
inline void s3account::clear_keys() {
  keys_.Clear();
}
inline ::s3service::s3accesskey* s3account::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:s3service.s3account.keys)
  return keys_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::s3service::s3accesskey >*
s3account::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:s3service.s3account.keys)
  return &keys_;
}
inline const ::s3service::s3accesskey& s3account::keys(int index) const {
  // @@protoc_insertion_point(field_get:s3service.s3account.keys)
  return keys_.Get(index);
}
inline ::s3service::s3accesskey* s3account::add_keys() {
  // @@protoc_insertion_point(field_add:s3service.s3account.keys)
  return keys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::s3service::s3accesskey >&
s3account::keys() const {
  // @@protoc_insertion_point(field_list:s3service.s3account.keys)
  return keys_;
}

// repeated .s3service.errorDetails errorInfo = 6;
inline int s3account::errorinfo_size() const {
  return errorinfo_.size();
}
inline void s3account::clear_errorinfo() {
  errorinfo_.Clear();
}
inline ::s3service::errorDetails* s3account::mutable_errorinfo(int index) {
  // @@protoc_insertion_point(field_mutable:s3service.s3account.errorInfo)
  return errorinfo_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::s3service::errorDetails >*
s3account::mutable_errorinfo() {
  // @@protoc_insertion_point(field_mutable_list:s3service.s3account.errorInfo)
  return &errorinfo_;
}
inline const ::s3service::errorDetails& s3account::errorinfo(int index) const {
  // @@protoc_insertion_point(field_get:s3service.s3account.errorInfo)
  return errorinfo_.Get(index);
}
inline ::s3service::errorDetails* s3account::add_errorinfo() {
  // @@protoc_insertion_point(field_add:s3service.s3account.errorInfo)
  return errorinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::s3service::errorDetails >&
s3account::errorinfo() const {
  // @@protoc_insertion_point(field_list:s3service.s3account.errorInfo)
  return errorinfo_;
}

// -------------------------------------------------------------------

// s3user

// .s3service.s3user.userOperation userOp = 1;
inline void s3user::clear_userop() {
  userop_ = 0;
}
inline ::s3service::s3user_userOperation s3user::userop() const {
  // @@protoc_insertion_point(field_get:s3service.s3user.userOp)
  return static_cast< ::s3service::s3user_userOperation >(userop_);
}
inline void s3user::set_userop(::s3service::s3user_userOperation value) {
  
  userop_ = value;
  // @@protoc_insertion_point(field_set:s3service.s3user.userOp)
}

// string username = 2;
inline void s3user::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& s3user::username() const {
  // @@protoc_insertion_point(field_get:s3service.s3user.username)
  return username_.GetNoArena();
}
inline void s3user::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.s3user.username)
}
#if LANG_CXX11
inline void s3user::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.s3user.username)
}
#endif
inline void s3user::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.s3user.username)
}
inline void s3user::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.s3user.username)
}
inline ::std::string* s3user::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:s3service.s3user.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* s3user::release_username() {
  // @@protoc_insertion_point(field_release:s3service.s3user.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void s3user::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:s3service.s3user.username)
}

// repeated .s3service.s3authorization auth = 3;
inline int s3user::auth_size() const {
  return auth_.size();
}
inline void s3user::clear_auth() {
  auth_.Clear();
}
inline ::s3service::s3authorization* s3user::mutable_auth(int index) {
  // @@protoc_insertion_point(field_mutable:s3service.s3user.auth)
  return auth_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::s3service::s3authorization >*
s3user::mutable_auth() {
  // @@protoc_insertion_point(field_mutable_list:s3service.s3user.auth)
  return &auth_;
}
inline const ::s3service::s3authorization& s3user::auth(int index) const {
  // @@protoc_insertion_point(field_get:s3service.s3user.auth)
  return auth_.Get(index);
}
inline ::s3service::s3authorization* s3user::add_auth() {
  // @@protoc_insertion_point(field_add:s3service.s3user.auth)
  return auth_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::s3service::s3authorization >&
s3user::auth() const {
  // @@protoc_insertion_point(field_list:s3service.s3user.auth)
  return auth_;
}

// repeated .s3service.errorDetails errorInfo = 4;
inline int s3user::errorinfo_size() const {
  return errorinfo_.size();
}
inline void s3user::clear_errorinfo() {
  errorinfo_.Clear();
}
inline ::s3service::errorDetails* s3user::mutable_errorinfo(int index) {
  // @@protoc_insertion_point(field_mutable:s3service.s3user.errorInfo)
  return errorinfo_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::s3service::errorDetails >*
s3user::mutable_errorinfo() {
  // @@protoc_insertion_point(field_mutable_list:s3service.s3user.errorInfo)
  return &errorinfo_;
}
inline const ::s3service::errorDetails& s3user::errorinfo(int index) const {
  // @@protoc_insertion_point(field_get:s3service.s3user.errorInfo)
  return errorinfo_.Get(index);
}
inline ::s3service::errorDetails* s3user::add_errorinfo() {
  // @@protoc_insertion_point(field_add:s3service.s3user.errorInfo)
  return errorinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::s3service::errorDetails >&
s3user::errorinfo() const {
  // @@protoc_insertion_point(field_list:s3service.s3user.errorInfo)
  return errorinfo_;
}

// string newusername = 5;
inline void s3user::clear_newusername() {
  newusername_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& s3user::newusername() const {
  // @@protoc_insertion_point(field_get:s3service.s3user.newusername)
  return newusername_.GetNoArena();
}
inline void s3user::set_newusername(const ::std::string& value) {
  
  newusername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.s3user.newusername)
}
#if LANG_CXX11
inline void s3user::set_newusername(::std::string&& value) {
  
  newusername_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.s3user.newusername)
}
#endif
inline void s3user::set_newusername(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  newusername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.s3user.newusername)
}
inline void s3user::set_newusername(const char* value, size_t size) {
  
  newusername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.s3user.newusername)
}
inline ::std::string* s3user::mutable_newusername() {
  
  // @@protoc_insertion_point(field_mutable:s3service.s3user.newusername)
  return newusername_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* s3user::release_newusername() {
  // @@protoc_insertion_point(field_release:s3service.s3user.newusername)
  
  return newusername_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void s3user::set_allocated_newusername(::std::string* newusername) {
  if (newusername != NULL) {
    
  } else {
    
  }
  newusername_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), newusername);
  // @@protoc_insertion_point(field_set_allocated:s3service.s3user.newusername)
}

// string permission = 6;
inline void s3user::clear_permission() {
  permission_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& s3user::permission() const {
  // @@protoc_insertion_point(field_get:s3service.s3user.permission)
  return permission_.GetNoArena();
}
inline void s3user::set_permission(const ::std::string& value) {
  
  permission_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.s3user.permission)
}
#if LANG_CXX11
inline void s3user::set_permission(::std::string&& value) {
  
  permission_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.s3user.permission)
}
#endif
inline void s3user::set_permission(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  permission_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.s3user.permission)
}
inline void s3user::set_permission(const char* value, size_t size) {
  
  permission_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.s3user.permission)
}
inline ::std::string* s3user::mutable_permission() {
  
  // @@protoc_insertion_point(field_mutable:s3service.s3user.permission)
  return permission_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* s3user::release_permission() {
  // @@protoc_insertion_point(field_release:s3service.s3user.permission)
  
  return permission_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void s3user::set_allocated_permission(::std::string* permission) {
  if (permission != NULL) {
    
  } else {
    
  }
  permission_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), permission);
  // @@protoc_insertion_point(field_set_allocated:s3service.s3user.permission)
}

// string test = 7;
inline void s3user::clear_test() {
  test_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& s3user::test() const {
  // @@protoc_insertion_point(field_get:s3service.s3user.test)
  return test_.GetNoArena();
}
inline void s3user::set_test(const ::std::string& value) {
  
  test_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.s3user.test)
}
#if LANG_CXX11
inline void s3user::set_test(::std::string&& value) {
  
  test_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.s3user.test)
}
#endif
inline void s3user::set_test(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  test_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.s3user.test)
}
inline void s3user::set_test(const char* value, size_t size) {
  
  test_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.s3user.test)
}
inline ::std::string* s3user::mutable_test() {
  
  // @@protoc_insertion_point(field_mutable:s3service.s3user.test)
  return test_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* s3user::release_test() {
  // @@protoc_insertion_point(field_release:s3service.s3user.test)
  
  return test_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void s3user::set_allocated_test(::std::string* test) {
  if (test != NULL) {
    
  } else {
    
  }
  test_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), test);
  // @@protoc_insertion_point(field_set_allocated:s3service.s3user.test)
}

// string userID = 8;
inline void s3user::clear_userid() {
  userid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& s3user::userid() const {
  // @@protoc_insertion_point(field_get:s3service.s3user.userID)
  return userid_.GetNoArena();
}
inline void s3user::set_userid(const ::std::string& value) {
  
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.s3user.userID)
}
#if LANG_CXX11
inline void s3user::set_userid(::std::string&& value) {
  
  userid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.s3user.userID)
}
#endif
inline void s3user::set_userid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.s3user.userID)
}
inline void s3user::set_userid(const char* value, size_t size) {
  
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.s3user.userID)
}
inline ::std::string* s3user::mutable_userid() {
  
  // @@protoc_insertion_point(field_mutable:s3service.s3user.userID)
  return userid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* s3user::release_userid() {
  // @@protoc_insertion_point(field_release:s3service.s3user.userID)
  
  return userid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void s3user::set_allocated_userid(::std::string* userid) {
  if (userid != NULL) {
    
  } else {
    
  }
  userid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), userid);
  // @@protoc_insertion_point(field_set_allocated:s3service.s3user.userID)
}

// string createDate = 9;
inline void s3user::clear_createdate() {
  createdate_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& s3user::createdate() const {
  // @@protoc_insertion_point(field_get:s3service.s3user.createDate)
  return createdate_.GetNoArena();
}
inline void s3user::set_createdate(const ::std::string& value) {
  
  createdate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.s3user.createDate)
}
#if LANG_CXX11
inline void s3user::set_createdate(::std::string&& value) {
  
  createdate_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.s3user.createDate)
}
#endif
inline void s3user::set_createdate(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  createdate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.s3user.createDate)
}
inline void s3user::set_createdate(const char* value, size_t size) {
  
  createdate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.s3user.createDate)
}
inline ::std::string* s3user::mutable_createdate() {
  
  // @@protoc_insertion_point(field_mutable:s3service.s3user.createDate)
  return createdate_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* s3user::release_createdate() {
  // @@protoc_insertion_point(field_release:s3service.s3user.createDate)
  
  return createdate_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void s3user::set_allocated_createdate(::std::string* createdate) {
  if (createdate != NULL) {
    
  } else {
    
  }
  createdate_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), createdate);
  // @@protoc_insertion_point(field_set_allocated:s3service.s3user.createDate)
}

// string arn = 10;
inline void s3user::clear_arn() {
  arn_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& s3user::arn() const {
  // @@protoc_insertion_point(field_get:s3service.s3user.arn)
  return arn_.GetNoArena();
}
inline void s3user::set_arn(const ::std::string& value) {
  
  arn_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.s3user.arn)
}
#if LANG_CXX11
inline void s3user::set_arn(::std::string&& value) {
  
  arn_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.s3user.arn)
}
#endif
inline void s3user::set_arn(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  arn_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.s3user.arn)
}
inline void s3user::set_arn(const char* value, size_t size) {
  
  arn_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.s3user.arn)
}
inline ::std::string* s3user::mutable_arn() {
  
  // @@protoc_insertion_point(field_mutable:s3service.s3user.arn)
  return arn_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* s3user::release_arn() {
  // @@protoc_insertion_point(field_release:s3service.s3user.arn)
  
  return arn_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void s3user::set_allocated_arn(::std::string* arn) {
  if (arn != NULL) {
    
  } else {
    
  }
  arn_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), arn);
  // @@protoc_insertion_point(field_set_allocated:s3service.s3user.arn)
}

// string path = 11;
inline void s3user::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& s3user::path() const {
  // @@protoc_insertion_point(field_get:s3service.s3user.path)
  return path_.GetNoArena();
}
inline void s3user::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.s3user.path)
}
#if LANG_CXX11
inline void s3user::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.s3user.path)
}
#endif
inline void s3user::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.s3user.path)
}
inline void s3user::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.s3user.path)
}
inline ::std::string* s3user::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:s3service.s3user.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* s3user::release_path() {
  // @@protoc_insertion_point(field_release:s3service.s3user.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void s3user::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:s3service.s3user.path)
}

// -------------------------------------------------------------------

// tags

// string key = 1;
inline void tags::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& tags::key() const {
  // @@protoc_insertion_point(field_get:s3service.tags.key)
  return key_.GetNoArena();
}
inline void tags::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.tags.key)
}
#if LANG_CXX11
inline void tags::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.tags.key)
}
#endif
inline void tags::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.tags.key)
}
inline void tags::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.tags.key)
}
inline ::std::string* tags::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:s3service.tags.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* tags::release_key() {
  // @@protoc_insertion_point(field_release:s3service.tags.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void tags::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:s3service.tags.key)
}

// string value = 2;
inline void tags::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& tags::value() const {
  // @@protoc_insertion_point(field_get:s3service.tags.value)
  return value_.GetNoArena();
}
inline void tags::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.tags.value)
}
#if LANG_CXX11
inline void tags::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.tags.value)
}
#endif
inline void tags::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.tags.value)
}
inline void tags::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.tags.value)
}
inline ::std::string* tags::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:s3service.tags.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* tags::release_value() {
  // @@protoc_insertion_point(field_release:s3service.tags.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void tags::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:s3service.tags.value)
}

// -------------------------------------------------------------------

// s3bucket

// .s3service.s3bucket.bucketOperation buckOp = 1;
inline void s3bucket::clear_buckop() {
  buckop_ = 0;
}
inline ::s3service::s3bucket_bucketOperation s3bucket::buckop() const {
  // @@protoc_insertion_point(field_get:s3service.s3bucket.buckOp)
  return static_cast< ::s3service::s3bucket_bucketOperation >(buckop_);
}
inline void s3bucket::set_buckop(::s3service::s3bucket_bucketOperation value) {
  
  buckop_ = value;
  // @@protoc_insertion_point(field_set:s3service.s3bucket.buckOp)
}

// repeated .s3service.s3authorization auth = 2;
inline int s3bucket::auth_size() const {
  return auth_.size();
}
inline void s3bucket::clear_auth() {
  auth_.Clear();
}
inline ::s3service::s3authorization* s3bucket::mutable_auth(int index) {
  // @@protoc_insertion_point(field_mutable:s3service.s3bucket.auth)
  return auth_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::s3service::s3authorization >*
s3bucket::mutable_auth() {
  // @@protoc_insertion_point(field_mutable_list:s3service.s3bucket.auth)
  return &auth_;
}
inline const ::s3service::s3authorization& s3bucket::auth(int index) const {
  // @@protoc_insertion_point(field_get:s3service.s3bucket.auth)
  return auth_.Get(index);
}
inline ::s3service::s3authorization* s3bucket::add_auth() {
  // @@protoc_insertion_point(field_add:s3service.s3bucket.auth)
  return auth_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::s3service::s3authorization >&
s3bucket::auth() const {
  // @@protoc_insertion_point(field_list:s3service.s3bucket.auth)
  return auth_;
}

// repeated .s3service.tags tag = 3;
inline int s3bucket::tag_size() const {
  return tag_.size();
}
inline void s3bucket::clear_tag() {
  tag_.Clear();
}
inline ::s3service::tags* s3bucket::mutable_tag(int index) {
  // @@protoc_insertion_point(field_mutable:s3service.s3bucket.tag)
  return tag_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::s3service::tags >*
s3bucket::mutable_tag() {
  // @@protoc_insertion_point(field_mutable_list:s3service.s3bucket.tag)
  return &tag_;
}
inline const ::s3service::tags& s3bucket::tag(int index) const {
  // @@protoc_insertion_point(field_get:s3service.s3bucket.tag)
  return tag_.Get(index);
}
inline ::s3service::tags* s3bucket::add_tag() {
  // @@protoc_insertion_point(field_add:s3service.s3bucket.tag)
  return tag_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::s3service::tags >&
s3bucket::tag() const {
  // @@protoc_insertion_point(field_list:s3service.s3bucket.tag)
  return tag_;
}

// repeated .s3service.errorDetails errorInfo = 4;
inline int s3bucket::errorinfo_size() const {
  return errorinfo_.size();
}
inline void s3bucket::clear_errorinfo() {
  errorinfo_.Clear();
}
inline ::s3service::errorDetails* s3bucket::mutable_errorinfo(int index) {
  // @@protoc_insertion_point(field_mutable:s3service.s3bucket.errorInfo)
  return errorinfo_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::s3service::errorDetails >*
s3bucket::mutable_errorinfo() {
  // @@protoc_insertion_point(field_mutable_list:s3service.s3bucket.errorInfo)
  return &errorinfo_;
}
inline const ::s3service::errorDetails& s3bucket::errorinfo(int index) const {
  // @@protoc_insertion_point(field_get:s3service.s3bucket.errorInfo)
  return errorinfo_.Get(index);
}
inline ::s3service::errorDetails* s3bucket::add_errorinfo() {
  // @@protoc_insertion_point(field_add:s3service.s3bucket.errorInfo)
  return errorinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::s3service::errorDetails >&
s3bucket::errorinfo() const {
  // @@protoc_insertion_point(field_list:s3service.s3bucket.errorInfo)
  return errorinfo_;
}

// string bucketName = 5;
inline void s3bucket::clear_bucketname() {
  bucketname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& s3bucket::bucketname() const {
  // @@protoc_insertion_point(field_get:s3service.s3bucket.bucketName)
  return bucketname_.GetNoArena();
}
inline void s3bucket::set_bucketname(const ::std::string& value) {
  
  bucketname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.s3bucket.bucketName)
}
#if LANG_CXX11
inline void s3bucket::set_bucketname(::std::string&& value) {
  
  bucketname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.s3bucket.bucketName)
}
#endif
inline void s3bucket::set_bucketname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  bucketname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.s3bucket.bucketName)
}
inline void s3bucket::set_bucketname(const char* value, size_t size) {
  
  bucketname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.s3bucket.bucketName)
}
inline ::std::string* s3bucket::mutable_bucketname() {
  
  // @@protoc_insertion_point(field_mutable:s3service.s3bucket.bucketName)
  return bucketname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* s3bucket::release_bucketname() {
  // @@protoc_insertion_point(field_release:s3service.s3bucket.bucketName)
  
  return bucketname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void s3bucket::set_allocated_bucketname(::std::string* bucketname) {
  if (bucketname != NULL) {
    
  } else {
    
  }
  bucketname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bucketname);
  // @@protoc_insertion_point(field_set_allocated:s3service.s3bucket.bucketName)
}

// .s3service.s3user currentUser = 6;
inline bool s3bucket::has_currentuser() const {
  return this != internal_default_instance() && currentuser_ != NULL;
}
inline void s3bucket::clear_currentuser() {
  if (GetArenaNoVirtual() == NULL && currentuser_ != NULL) {
    delete currentuser_;
  }
  currentuser_ = NULL;
}
inline const ::s3service::s3user& s3bucket::_internal_currentuser() const {
  return *currentuser_;
}
inline const ::s3service::s3user& s3bucket::currentuser() const {
  const ::s3service::s3user* p = currentuser_;
  // @@protoc_insertion_point(field_get:s3service.s3bucket.currentUser)
  return p != NULL ? *p : *reinterpret_cast<const ::s3service::s3user*>(
      &::s3service::_s3user_default_instance_);
}
inline ::s3service::s3user* s3bucket::release_currentuser() {
  // @@protoc_insertion_point(field_release:s3service.s3bucket.currentUser)
  
  ::s3service::s3user* temp = currentuser_;
  currentuser_ = NULL;
  return temp;
}
inline ::s3service::s3user* s3bucket::mutable_currentuser() {
  
  if (currentuser_ == NULL) {
    auto* p = CreateMaybeMessage<::s3service::s3user>(GetArenaNoVirtual());
    currentuser_ = p;
  }
  // @@protoc_insertion_point(field_mutable:s3service.s3bucket.currentUser)
  return currentuser_;
}
inline void s3bucket::set_allocated_currentuser(::s3service::s3user* currentuser) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete currentuser_;
  }
  if (currentuser) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      currentuser = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, currentuser, submessage_arena);
    }
    
  } else {
    
  }
  currentuser_ = currentuser;
  // @@protoc_insertion_point(field_set_allocated:s3service.s3bucket.currentUser)
}

// .s3service.s3user bucketOwner = 7;
inline bool s3bucket::has_bucketowner() const {
  return this != internal_default_instance() && bucketowner_ != NULL;
}
inline void s3bucket::clear_bucketowner() {
  if (GetArenaNoVirtual() == NULL && bucketowner_ != NULL) {
    delete bucketowner_;
  }
  bucketowner_ = NULL;
}
inline const ::s3service::s3user& s3bucket::_internal_bucketowner() const {
  return *bucketowner_;
}
inline const ::s3service::s3user& s3bucket::bucketowner() const {
  const ::s3service::s3user* p = bucketowner_;
  // @@protoc_insertion_point(field_get:s3service.s3bucket.bucketOwner)
  return p != NULL ? *p : *reinterpret_cast<const ::s3service::s3user*>(
      &::s3service::_s3user_default_instance_);
}
inline ::s3service::s3user* s3bucket::release_bucketowner() {
  // @@protoc_insertion_point(field_release:s3service.s3bucket.bucketOwner)
  
  ::s3service::s3user* temp = bucketowner_;
  bucketowner_ = NULL;
  return temp;
}
inline ::s3service::s3user* s3bucket::mutable_bucketowner() {
  
  if (bucketowner_ == NULL) {
    auto* p = CreateMaybeMessage<::s3service::s3user>(GetArenaNoVirtual());
    bucketowner_ = p;
  }
  // @@protoc_insertion_point(field_mutable:s3service.s3bucket.bucketOwner)
  return bucketowner_;
}
inline void s3bucket::set_allocated_bucketowner(::s3service::s3user* bucketowner) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete bucketowner_;
  }
  if (bucketowner) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      bucketowner = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bucketowner, submessage_arena);
    }
    
  } else {
    
  }
  bucketowner_ = bucketowner;
  // @@protoc_insertion_point(field_set_allocated:s3service.s3bucket.bucketOwner)
}

// string version = 8;
inline void s3bucket::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& s3bucket::version() const {
  // @@protoc_insertion_point(field_get:s3service.s3bucket.version)
  return version_.GetNoArena();
}
inline void s3bucket::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.s3bucket.version)
}
#if LANG_CXX11
inline void s3bucket::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.s3bucket.version)
}
#endif
inline void s3bucket::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.s3bucket.version)
}
inline void s3bucket::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.s3bucket.version)
}
inline ::std::string* s3bucket::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:s3service.s3bucket.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* s3bucket::release_version() {
  // @@protoc_insertion_point(field_release:s3service.s3bucket.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void s3bucket::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:s3service.s3bucket.version)
}

// string list_object = 9;
inline void s3bucket::clear_list_object() {
  list_object_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& s3bucket::list_object() const {
  // @@protoc_insertion_point(field_get:s3service.s3bucket.list_object)
  return list_object_.GetNoArena();
}
inline void s3bucket::set_list_object(const ::std::string& value) {
  
  list_object_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.s3bucket.list_object)
}
#if LANG_CXX11
inline void s3bucket::set_list_object(::std::string&& value) {
  
  list_object_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.s3bucket.list_object)
}
#endif
inline void s3bucket::set_list_object(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  list_object_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.s3bucket.list_object)
}
inline void s3bucket::set_list_object(const char* value, size_t size) {
  
  list_object_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.s3bucket.list_object)
}
inline ::std::string* s3bucket::mutable_list_object() {
  
  // @@protoc_insertion_point(field_mutable:s3service.s3bucket.list_object)
  return list_object_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* s3bucket::release_list_object() {
  // @@protoc_insertion_point(field_release:s3service.s3bucket.list_object)
  
  return list_object_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void s3bucket::set_allocated_list_object(::std::string* list_object) {
  if (list_object != NULL) {
    
  } else {
    
  }
  list_object_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), list_object);
  // @@protoc_insertion_point(field_set_allocated:s3service.s3bucket.list_object)
}

// string list_object_versions = 10;
inline void s3bucket::clear_list_object_versions() {
  list_object_versions_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& s3bucket::list_object_versions() const {
  // @@protoc_insertion_point(field_get:s3service.s3bucket.list_object_versions)
  return list_object_versions_.GetNoArena();
}
inline void s3bucket::set_list_object_versions(const ::std::string& value) {
  
  list_object_versions_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.s3bucket.list_object_versions)
}
#if LANG_CXX11
inline void s3bucket::set_list_object_versions(::std::string&& value) {
  
  list_object_versions_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.s3bucket.list_object_versions)
}
#endif
inline void s3bucket::set_list_object_versions(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  list_object_versions_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.s3bucket.list_object_versions)
}
inline void s3bucket::set_list_object_versions(const char* value, size_t size) {
  
  list_object_versions_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.s3bucket.list_object_versions)
}
inline ::std::string* s3bucket::mutable_list_object_versions() {
  
  // @@protoc_insertion_point(field_mutable:s3service.s3bucket.list_object_versions)
  return list_object_versions_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* s3bucket::release_list_object_versions() {
  // @@protoc_insertion_point(field_release:s3service.s3bucket.list_object_versions)
  
  return list_object_versions_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void s3bucket::set_allocated_list_object_versions(::std::string* list_object_versions) {
  if (list_object_versions != NULL) {
    
  } else {
    
  }
  list_object_versions_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), list_object_versions);
  // @@protoc_insertion_point(field_set_allocated:s3service.s3bucket.list_object_versions)
}

// string archive = 11;
inline void s3bucket::clear_archive() {
  archive_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& s3bucket::archive() const {
  // @@protoc_insertion_point(field_get:s3service.s3bucket.archive)
  return archive_.GetNoArena();
}
inline void s3bucket::set_archive(const ::std::string& value) {
  
  archive_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.s3bucket.archive)
}
#if LANG_CXX11
inline void s3bucket::set_archive(::std::string&& value) {
  
  archive_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.s3bucket.archive)
}
#endif
inline void s3bucket::set_archive(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  archive_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.s3bucket.archive)
}
inline void s3bucket::set_archive(const char* value, size_t size) {
  
  archive_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.s3bucket.archive)
}
inline ::std::string* s3bucket::mutable_archive() {
  
  // @@protoc_insertion_point(field_mutable:s3service.s3bucket.archive)
  return archive_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* s3bucket::release_archive() {
  // @@protoc_insertion_point(field_release:s3service.s3bucket.archive)
  
  return archive_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void s3bucket::set_allocated_archive(::std::string* archive) {
  if (archive != NULL) {
    
  } else {
    
  }
  archive_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), archive);
  // @@protoc_insertion_point(field_set_allocated:s3service.s3bucket.archive)
}

// string expiry_date = 12;
inline void s3bucket::clear_expiry_date() {
  expiry_date_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& s3bucket::expiry_date() const {
  // @@protoc_insertion_point(field_get:s3service.s3bucket.expiry_date)
  return expiry_date_.GetNoArena();
}
inline void s3bucket::set_expiry_date(const ::std::string& value) {
  
  expiry_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.s3bucket.expiry_date)
}
#if LANG_CXX11
inline void s3bucket::set_expiry_date(::std::string&& value) {
  
  expiry_date_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.s3bucket.expiry_date)
}
#endif
inline void s3bucket::set_expiry_date(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  expiry_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.s3bucket.expiry_date)
}
inline void s3bucket::set_expiry_date(const char* value, size_t size) {
  
  expiry_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.s3bucket.expiry_date)
}
inline ::std::string* s3bucket::mutable_expiry_date() {
  
  // @@protoc_insertion_point(field_mutable:s3service.s3bucket.expiry_date)
  return expiry_date_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* s3bucket::release_expiry_date() {
  // @@protoc_insertion_point(field_release:s3service.s3bucket.expiry_date)
  
  return expiry_date_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void s3bucket::set_allocated_expiry_date(::std::string* expiry_date) {
  if (expiry_date != NULL) {
    
  } else {
    
  }
  expiry_date_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), expiry_date);
  // @@protoc_insertion_point(field_set_allocated:s3service.s3bucket.expiry_date)
}

// string storageQuota = 13;
inline void s3bucket::clear_storagequota() {
  storagequota_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& s3bucket::storagequota() const {
  // @@protoc_insertion_point(field_get:s3service.s3bucket.storageQuota)
  return storagequota_.GetNoArena();
}
inline void s3bucket::set_storagequota(const ::std::string& value) {
  
  storagequota_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.s3bucket.storageQuota)
}
#if LANG_CXX11
inline void s3bucket::set_storagequota(::std::string&& value) {
  
  storagequota_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.s3bucket.storageQuota)
}
#endif
inline void s3bucket::set_storagequota(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  storagequota_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.s3bucket.storageQuota)
}
inline void s3bucket::set_storagequota(const char* value, size_t size) {
  
  storagequota_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.s3bucket.storageQuota)
}
inline ::std::string* s3bucket::mutable_storagequota() {
  
  // @@protoc_insertion_point(field_mutable:s3service.s3bucket.storageQuota)
  return storagequota_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* s3bucket::release_storagequota() {
  // @@protoc_insertion_point(field_release:s3service.s3bucket.storageQuota)
  
  return storagequota_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void s3bucket::set_allocated_storagequota(::std::string* storagequota) {
  if (storagequota != NULL) {
    
  } else {
    
  }
  storagequota_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), storagequota);
  // @@protoc_insertion_point(field_set_allocated:s3service.s3bucket.storageQuota)
}

// string storageLens = 14;
inline void s3bucket::clear_storagelens() {
  storagelens_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& s3bucket::storagelens() const {
  // @@protoc_insertion_point(field_get:s3service.s3bucket.storageLens)
  return storagelens_.GetNoArena();
}
inline void s3bucket::set_storagelens(const ::std::string& value) {
  
  storagelens_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.s3bucket.storageLens)
}
#if LANG_CXX11
inline void s3bucket::set_storagelens(::std::string&& value) {
  
  storagelens_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.s3bucket.storageLens)
}
#endif
inline void s3bucket::set_storagelens(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  storagelens_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.s3bucket.storageLens)
}
inline void s3bucket::set_storagelens(const char* value, size_t size) {
  
  storagelens_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.s3bucket.storageLens)
}
inline ::std::string* s3bucket::mutable_storagelens() {
  
  // @@protoc_insertion_point(field_mutable:s3service.s3bucket.storageLens)
  return storagelens_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* s3bucket::release_storagelens() {
  // @@protoc_insertion_point(field_release:s3service.s3bucket.storageLens)
  
  return storagelens_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void s3bucket::set_allocated_storagelens(::std::string* storagelens) {
  if (storagelens != NULL) {
    
  } else {
    
  }
  storagelens_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), storagelens);
  // @@protoc_insertion_point(field_set_allocated:s3service.s3bucket.storageLens)
}

// string total_size = 15;
inline void s3bucket::clear_total_size() {
  total_size_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& s3bucket::total_size() const {
  // @@protoc_insertion_point(field_get:s3service.s3bucket.total_size)
  return total_size_.GetNoArena();
}
inline void s3bucket::set_total_size(const ::std::string& value) {
  
  total_size_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.s3bucket.total_size)
}
#if LANG_CXX11
inline void s3bucket::set_total_size(::std::string&& value) {
  
  total_size_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.s3bucket.total_size)
}
#endif
inline void s3bucket::set_total_size(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  total_size_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.s3bucket.total_size)
}
inline void s3bucket::set_total_size(const char* value, size_t size) {
  
  total_size_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.s3bucket.total_size)
}
inline ::std::string* s3bucket::mutable_total_size() {
  
  // @@protoc_insertion_point(field_mutable:s3service.s3bucket.total_size)
  return total_size_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* s3bucket::release_total_size() {
  // @@protoc_insertion_point(field_release:s3service.s3bucket.total_size)
  
  return total_size_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void s3bucket::set_allocated_total_size(::std::string* total_size) {
  if (total_size != NULL) {
    
  } else {
    
  }
  total_size_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), total_size);
  // @@protoc_insertion_point(field_set_allocated:s3service.s3bucket.total_size)
}

// string size_consumed = 16;
inline void s3bucket::clear_size_consumed() {
  size_consumed_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& s3bucket::size_consumed() const {
  // @@protoc_insertion_point(field_get:s3service.s3bucket.size_consumed)
  return size_consumed_.GetNoArena();
}
inline void s3bucket::set_size_consumed(const ::std::string& value) {
  
  size_consumed_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.s3bucket.size_consumed)
}
#if LANG_CXX11
inline void s3bucket::set_size_consumed(::std::string&& value) {
  
  size_consumed_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.s3bucket.size_consumed)
}
#endif
inline void s3bucket::set_size_consumed(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  size_consumed_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.s3bucket.size_consumed)
}
inline void s3bucket::set_size_consumed(const char* value, size_t size) {
  
  size_consumed_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.s3bucket.size_consumed)
}
inline ::std::string* s3bucket::mutable_size_consumed() {
  
  // @@protoc_insertion_point(field_mutable:s3service.s3bucket.size_consumed)
  return size_consumed_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* s3bucket::release_size_consumed() {
  // @@protoc_insertion_point(field_release:s3service.s3bucket.size_consumed)
  
  return size_consumed_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void s3bucket::set_allocated_size_consumed(::std::string* size_consumed) {
  if (size_consumed != NULL) {
    
  } else {
    
  }
  size_consumed_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), size_consumed);
  // @@protoc_insertion_point(field_set_allocated:s3service.s3bucket.size_consumed)
}

// string free_space = 17;
inline void s3bucket::clear_free_space() {
  free_space_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& s3bucket::free_space() const {
  // @@protoc_insertion_point(field_get:s3service.s3bucket.free_space)
  return free_space_.GetNoArena();
}
inline void s3bucket::set_free_space(const ::std::string& value) {
  
  free_space_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.s3bucket.free_space)
}
#if LANG_CXX11
inline void s3bucket::set_free_space(::std::string&& value) {
  
  free_space_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.s3bucket.free_space)
}
#endif
inline void s3bucket::set_free_space(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  free_space_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.s3bucket.free_space)
}
inline void s3bucket::set_free_space(const char* value, size_t size) {
  
  free_space_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.s3bucket.free_space)
}
inline ::std::string* s3bucket::mutable_free_space() {
  
  // @@protoc_insertion_point(field_mutable:s3service.s3bucket.free_space)
  return free_space_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* s3bucket::release_free_space() {
  // @@protoc_insertion_point(field_release:s3service.s3bucket.free_space)
  
  return free_space_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void s3bucket::set_allocated_free_space(::std::string* free_space) {
  if (free_space != NULL) {
    
  } else {
    
  }
  free_space_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), free_space);
  // @@protoc_insertion_point(field_set_allocated:s3service.s3bucket.free_space)
}

// -------------------------------------------------------------------

// s3object

// .s3service.s3object.objectOperation objectOp = 1;
inline void s3object::clear_objectop() {
  objectop_ = 0;
}
inline ::s3service::s3object_objectOperation s3object::objectop() const {
  // @@protoc_insertion_point(field_get:s3service.s3object.objectOp)
  return static_cast< ::s3service::s3object_objectOperation >(objectop_);
}
inline void s3object::set_objectop(::s3service::s3object_objectOperation value) {
  
  objectop_ = value;
  // @@protoc_insertion_point(field_set:s3service.s3object.objectOp)
}

// repeated .s3service.s3authorization auth = 2;
inline int s3object::auth_size() const {
  return auth_.size();
}
inline void s3object::clear_auth() {
  auth_.Clear();
}
inline ::s3service::s3authorization* s3object::mutable_auth(int index) {
  // @@protoc_insertion_point(field_mutable:s3service.s3object.auth)
  return auth_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::s3service::s3authorization >*
s3object::mutable_auth() {
  // @@protoc_insertion_point(field_mutable_list:s3service.s3object.auth)
  return &auth_;
}
inline const ::s3service::s3authorization& s3object::auth(int index) const {
  // @@protoc_insertion_point(field_get:s3service.s3object.auth)
  return auth_.Get(index);
}
inline ::s3service::s3authorization* s3object::add_auth() {
  // @@protoc_insertion_point(field_add:s3service.s3object.auth)
  return auth_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::s3service::s3authorization >&
s3object::auth() const {
  // @@protoc_insertion_point(field_list:s3service.s3object.auth)
  return auth_;
}

// repeated .s3service.errorDetails errorInfo = 3;
inline int s3object::errorinfo_size() const {
  return errorinfo_.size();
}
inline void s3object::clear_errorinfo() {
  errorinfo_.Clear();
}
inline ::s3service::errorDetails* s3object::mutable_errorinfo(int index) {
  // @@protoc_insertion_point(field_mutable:s3service.s3object.errorInfo)
  return errorinfo_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::s3service::errorDetails >*
s3object::mutable_errorinfo() {
  // @@protoc_insertion_point(field_mutable_list:s3service.s3object.errorInfo)
  return &errorinfo_;
}
inline const ::s3service::errorDetails& s3object::errorinfo(int index) const {
  // @@protoc_insertion_point(field_get:s3service.s3object.errorInfo)
  return errorinfo_.Get(index);
}
inline ::s3service::errorDetails* s3object::add_errorinfo() {
  // @@protoc_insertion_point(field_add:s3service.s3object.errorInfo)
  return errorinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::s3service::errorDetails >&
s3object::errorinfo() const {
  // @@protoc_insertion_point(field_list:s3service.s3object.errorInfo)
  return errorinfo_;
}

// string bucketName = 4;
inline void s3object::clear_bucketname() {
  bucketname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& s3object::bucketname() const {
  // @@protoc_insertion_point(field_get:s3service.s3object.bucketName)
  return bucketname_.GetNoArena();
}
inline void s3object::set_bucketname(const ::std::string& value) {
  
  bucketname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.s3object.bucketName)
}
#if LANG_CXX11
inline void s3object::set_bucketname(::std::string&& value) {
  
  bucketname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.s3object.bucketName)
}
#endif
inline void s3object::set_bucketname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  bucketname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.s3object.bucketName)
}
inline void s3object::set_bucketname(const char* value, size_t size) {
  
  bucketname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.s3object.bucketName)
}
inline ::std::string* s3object::mutable_bucketname() {
  
  // @@protoc_insertion_point(field_mutable:s3service.s3object.bucketName)
  return bucketname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* s3object::release_bucketname() {
  // @@protoc_insertion_point(field_release:s3service.s3object.bucketName)
  
  return bucketname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void s3object::set_allocated_bucketname(::std::string* bucketname) {
  if (bucketname != NULL) {
    
  } else {
    
  }
  bucketname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bucketname);
  // @@protoc_insertion_point(field_set_allocated:s3service.s3object.bucketName)
}

// string objectName = 5;
inline void s3object::clear_objectname() {
  objectname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& s3object::objectname() const {
  // @@protoc_insertion_point(field_get:s3service.s3object.objectName)
  return objectname_.GetNoArena();
}
inline void s3object::set_objectname(const ::std::string& value) {
  
  objectname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.s3object.objectName)
}
#if LANG_CXX11
inline void s3object::set_objectname(::std::string&& value) {
  
  objectname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.s3object.objectName)
}
#endif
inline void s3object::set_objectname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  objectname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.s3object.objectName)
}
inline void s3object::set_objectname(const char* value, size_t size) {
  
  objectname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.s3object.objectName)
}
inline ::std::string* s3object::mutable_objectname() {
  
  // @@protoc_insertion_point(field_mutable:s3service.s3object.objectName)
  return objectname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* s3object::release_objectname() {
  // @@protoc_insertion_point(field_release:s3service.s3object.objectName)
  
  return objectname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void s3object::set_allocated_objectname(::std::string* objectname) {
  if (objectname != NULL) {
    
  } else {
    
  }
  objectname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), objectname);
  // @@protoc_insertion_point(field_set_allocated:s3service.s3object.objectName)
}

// int32 len = 6;
inline void s3object::clear_len() {
  len_ = 0;
}
inline ::google::protobuf::int32 s3object::len() const {
  // @@protoc_insertion_point(field_get:s3service.s3object.len)
  return len_;
}
inline void s3object::set_len(::google::protobuf::int32 value) {
  
  len_ = value;
  // @@protoc_insertion_point(field_set:s3service.s3object.len)
}

// string objectPath = 7;
inline void s3object::clear_objectpath() {
  objectpath_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& s3object::objectpath() const {
  // @@protoc_insertion_point(field_get:s3service.s3object.objectPath)
  return objectpath_.GetNoArena();
}
inline void s3object::set_objectpath(const ::std::string& value) {
  
  objectpath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.s3object.objectPath)
}
#if LANG_CXX11
inline void s3object::set_objectpath(::std::string&& value) {
  
  objectpath_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.s3object.objectPath)
}
#endif
inline void s3object::set_objectpath(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  objectpath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.s3object.objectPath)
}
inline void s3object::set_objectpath(const char* value, size_t size) {
  
  objectpath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.s3object.objectPath)
}
inline ::std::string* s3object::mutable_objectpath() {
  
  // @@protoc_insertion_point(field_mutable:s3service.s3object.objectPath)
  return objectpath_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* s3object::release_objectpath() {
  // @@protoc_insertion_point(field_release:s3service.s3object.objectPath)
  
  return objectpath_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void s3object::set_allocated_objectpath(::std::string* objectpath) {
  if (objectpath != NULL) {
    
  } else {
    
  }
  objectpath_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), objectpath);
  // @@protoc_insertion_point(field_set_allocated:s3service.s3object.objectPath)
}

// string tag = 8;
inline void s3object::clear_tag() {
  tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& s3object::tag() const {
  // @@protoc_insertion_point(field_get:s3service.s3object.tag)
  return tag_.GetNoArena();
}
inline void s3object::set_tag(const ::std::string& value) {
  
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.s3object.tag)
}
#if LANG_CXX11
inline void s3object::set_tag(::std::string&& value) {
  
  tag_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.s3object.tag)
}
#endif
inline void s3object::set_tag(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.s3object.tag)
}
inline void s3object::set_tag(const char* value, size_t size) {
  
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.s3object.tag)
}
inline ::std::string* s3object::mutable_tag() {
  
  // @@protoc_insertion_point(field_mutable:s3service.s3object.tag)
  return tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* s3object::release_tag() {
  // @@protoc_insertion_point(field_release:s3service.s3object.tag)
  
  return tag_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void s3object::set_allocated_tag(::std::string* tag) {
  if (tag != NULL) {
    
  } else {
    
  }
  tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tag);
  // @@protoc_insertion_point(field_set_allocated:s3service.s3object.tag)
}

// string putId = 9;
inline void s3object::clear_putid() {
  putid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& s3object::putid() const {
  // @@protoc_insertion_point(field_get:s3service.s3object.putId)
  return putid_.GetNoArena();
}
inline void s3object::set_putid(const ::std::string& value) {
  
  putid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.s3object.putId)
}
#if LANG_CXX11
inline void s3object::set_putid(::std::string&& value) {
  
  putid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.s3object.putId)
}
#endif
inline void s3object::set_putid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  putid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.s3object.putId)
}
inline void s3object::set_putid(const char* value, size_t size) {
  
  putid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.s3object.putId)
}
inline ::std::string* s3object::mutable_putid() {
  
  // @@protoc_insertion_point(field_mutable:s3service.s3object.putId)
  return putid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* s3object::release_putid() {
  // @@protoc_insertion_point(field_release:s3service.s3object.putId)
  
  return putid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void s3object::set_allocated_putid(::std::string* putid) {
  if (putid != NULL) {
    
  } else {
    
  }
  putid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), putid);
  // @@protoc_insertion_point(field_set_allocated:s3service.s3object.putId)
}

// string versionId = 10;
inline void s3object::clear_versionid() {
  versionid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& s3object::versionid() const {
  // @@protoc_insertion_point(field_get:s3service.s3object.versionId)
  return versionid_.GetNoArena();
}
inline void s3object::set_versionid(const ::std::string& value) {
  
  versionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.s3object.versionId)
}
#if LANG_CXX11
inline void s3object::set_versionid(::std::string&& value) {
  
  versionid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.s3object.versionId)
}
#endif
inline void s3object::set_versionid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  versionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.s3object.versionId)
}
inline void s3object::set_versionid(const char* value, size_t size) {
  
  versionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.s3object.versionId)
}
inline ::std::string* s3object::mutable_versionid() {
  
  // @@protoc_insertion_point(field_mutable:s3service.s3object.versionId)
  return versionid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* s3object::release_versionid() {
  // @@protoc_insertion_point(field_release:s3service.s3object.versionId)
  
  return versionid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void s3object::set_allocated_versionid(::std::string* versionid) {
  if (versionid != NULL) {
    
  } else {
    
  }
  versionid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), versionid);
  // @@protoc_insertion_point(field_set_allocated:s3service.s3object.versionId)
}

// string list_object = 14;
inline void s3object::clear_list_object() {
  list_object_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& s3object::list_object() const {
  // @@protoc_insertion_point(field_get:s3service.s3object.list_object)
  return list_object_.GetNoArena();
}
inline void s3object::set_list_object(const ::std::string& value) {
  
  list_object_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.s3object.list_object)
}
#if LANG_CXX11
inline void s3object::set_list_object(::std::string&& value) {
  
  list_object_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.s3object.list_object)
}
#endif
inline void s3object::set_list_object(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  list_object_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.s3object.list_object)
}
inline void s3object::set_list_object(const char* value, size_t size) {
  
  list_object_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.s3object.list_object)
}
inline ::std::string* s3object::mutable_list_object() {
  
  // @@protoc_insertion_point(field_mutable:s3service.s3object.list_object)
  return list_object_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* s3object::release_list_object() {
  // @@protoc_insertion_point(field_release:s3service.s3object.list_object)
  
  return list_object_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void s3object::set_allocated_list_object(::std::string* list_object) {
  if (list_object != NULL) {
    
  } else {
    
  }
  list_object_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), list_object);
  // @@protoc_insertion_point(field_set_allocated:s3service.s3object.list_object)
}

// string getobjectbyversionId = 15;
inline void s3object::clear_getobjectbyversionid() {
  getobjectbyversionid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& s3object::getobjectbyversionid() const {
  // @@protoc_insertion_point(field_get:s3service.s3object.getobjectbyversionId)
  return getobjectbyversionid_.GetNoArena();
}
inline void s3object::set_getobjectbyversionid(const ::std::string& value) {
  
  getobjectbyversionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.s3object.getobjectbyversionId)
}
#if LANG_CXX11
inline void s3object::set_getobjectbyversionid(::std::string&& value) {
  
  getobjectbyversionid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.s3object.getobjectbyversionId)
}
#endif
inline void s3object::set_getobjectbyversionid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  getobjectbyversionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.s3object.getobjectbyversionId)
}
inline void s3object::set_getobjectbyversionid(const char* value, size_t size) {
  
  getobjectbyversionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.s3object.getobjectbyversionId)
}
inline ::std::string* s3object::mutable_getobjectbyversionid() {
  
  // @@protoc_insertion_point(field_mutable:s3service.s3object.getobjectbyversionId)
  return getobjectbyversionid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* s3object::release_getobjectbyversionid() {
  // @@protoc_insertion_point(field_release:s3service.s3object.getobjectbyversionId)
  
  return getobjectbyversionid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void s3object::set_allocated_getobjectbyversionid(::std::string* getobjectbyversionid) {
  if (getobjectbyversionid != NULL) {
    
  } else {
    
  }
  getobjectbyversionid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), getobjectbyversionid);
  // @@protoc_insertion_point(field_set_allocated:s3service.s3object.getobjectbyversionId)
}

// string listdeleteMarker = 16;
inline void s3object::clear_listdeletemarker() {
  listdeletemarker_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& s3object::listdeletemarker() const {
  // @@protoc_insertion_point(field_get:s3service.s3object.listdeleteMarker)
  return listdeletemarker_.GetNoArena();
}
inline void s3object::set_listdeletemarker(const ::std::string& value) {
  
  listdeletemarker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.s3object.listdeleteMarker)
}
#if LANG_CXX11
inline void s3object::set_listdeletemarker(::std::string&& value) {
  
  listdeletemarker_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.s3object.listdeleteMarker)
}
#endif
inline void s3object::set_listdeletemarker(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  listdeletemarker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.s3object.listdeleteMarker)
}
inline void s3object::set_listdeletemarker(const char* value, size_t size) {
  
  listdeletemarker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.s3object.listdeleteMarker)
}
inline ::std::string* s3object::mutable_listdeletemarker() {
  
  // @@protoc_insertion_point(field_mutable:s3service.s3object.listdeleteMarker)
  return listdeletemarker_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* s3object::release_listdeletemarker() {
  // @@protoc_insertion_point(field_release:s3service.s3object.listdeleteMarker)
  
  return listdeletemarker_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void s3object::set_allocated_listdeletemarker(::std::string* listdeletemarker) {
  if (listdeletemarker != NULL) {
    
  } else {
    
  }
  listdeletemarker_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), listdeletemarker);
  // @@protoc_insertion_point(field_set_allocated:s3service.s3object.listdeleteMarker)
}

// string markerId = 17;
inline void s3object::clear_markerid() {
  markerid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& s3object::markerid() const {
  // @@protoc_insertion_point(field_get:s3service.s3object.markerId)
  return markerid_.GetNoArena();
}
inline void s3object::set_markerid(const ::std::string& value) {
  
  markerid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.s3object.markerId)
}
#if LANG_CXX11
inline void s3object::set_markerid(::std::string&& value) {
  
  markerid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.s3object.markerId)
}
#endif
inline void s3object::set_markerid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  markerid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.s3object.markerId)
}
inline void s3object::set_markerid(const char* value, size_t size) {
  
  markerid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.s3object.markerId)
}
inline ::std::string* s3object::mutable_markerid() {
  
  // @@protoc_insertion_point(field_mutable:s3service.s3object.markerId)
  return markerid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* s3object::release_markerid() {
  // @@protoc_insertion_point(field_release:s3service.s3object.markerId)
  
  return markerid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void s3object::set_allocated_markerid(::std::string* markerid) {
  if (markerid != NULL) {
    
  } else {
    
  }
  markerid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), markerid);
  // @@protoc_insertion_point(field_set_allocated:s3service.s3object.markerId)
}

// string filecount = 18;
inline void s3object::clear_filecount() {
  filecount_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& s3object::filecount() const {
  // @@protoc_insertion_point(field_get:s3service.s3object.filecount)
  return filecount_.GetNoArena();
}
inline void s3object::set_filecount(const ::std::string& value) {
  
  filecount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.s3object.filecount)
}
#if LANG_CXX11
inline void s3object::set_filecount(::std::string&& value) {
  
  filecount_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.s3object.filecount)
}
#endif
inline void s3object::set_filecount(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  filecount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.s3object.filecount)
}
inline void s3object::set_filecount(const char* value, size_t size) {
  
  filecount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.s3object.filecount)
}
inline ::std::string* s3object::mutable_filecount() {
  
  // @@protoc_insertion_point(field_mutable:s3service.s3object.filecount)
  return filecount_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* s3object::release_filecount() {
  // @@protoc_insertion_point(field_release:s3service.s3object.filecount)
  
  return filecount_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void s3object::set_allocated_filecount(::std::string* filecount) {
  if (filecount != NULL) {
    
  } else {
    
  }
  filecount_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filecount);
  // @@protoc_insertion_point(field_set_allocated:s3service.s3object.filecount)
}

// string filename = 19;
inline void s3object::clear_filename() {
  filename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& s3object::filename() const {
  // @@protoc_insertion_point(field_get:s3service.s3object.filename)
  return filename_.GetNoArena();
}
inline void s3object::set_filename(const ::std::string& value) {
  
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.s3object.filename)
}
#if LANG_CXX11
inline void s3object::set_filename(::std::string&& value) {
  
  filename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.s3object.filename)
}
#endif
inline void s3object::set_filename(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.s3object.filename)
}
inline void s3object::set_filename(const char* value, size_t size) {
  
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.s3object.filename)
}
inline ::std::string* s3object::mutable_filename() {
  
  // @@protoc_insertion_point(field_mutable:s3service.s3object.filename)
  return filename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* s3object::release_filename() {
  // @@protoc_insertion_point(field_release:s3service.s3object.filename)
  
  return filename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void s3object::set_allocated_filename(::std::string* filename) {
  if (filename != NULL) {
    
  } else {
    
  }
  filename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filename);
  // @@protoc_insertion_point(field_set_allocated:s3service.s3object.filename)
}

// string filesize = 20;
inline void s3object::clear_filesize() {
  filesize_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& s3object::filesize() const {
  // @@protoc_insertion_point(field_get:s3service.s3object.filesize)
  return filesize_.GetNoArena();
}
inline void s3object::set_filesize(const ::std::string& value) {
  
  filesize_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.s3object.filesize)
}
#if LANG_CXX11
inline void s3object::set_filesize(::std::string&& value) {
  
  filesize_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.s3object.filesize)
}
#endif
inline void s3object::set_filesize(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  filesize_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.s3object.filesize)
}
inline void s3object::set_filesize(const char* value, size_t size) {
  
  filesize_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.s3object.filesize)
}
inline ::std::string* s3object::mutable_filesize() {
  
  // @@protoc_insertion_point(field_mutable:s3service.s3object.filesize)
  return filesize_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* s3object::release_filesize() {
  // @@protoc_insertion_point(field_release:s3service.s3object.filesize)
  
  return filesize_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void s3object::set_allocated_filesize(::std::string* filesize) {
  if (filesize != NULL) {
    
  } else {
    
  }
  filesize_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filesize);
  // @@protoc_insertion_point(field_set_allocated:s3service.s3object.filesize)
}

// string file = 21;
inline void s3object::clear_file() {
  file_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& s3object::file() const {
  // @@protoc_insertion_point(field_get:s3service.s3object.file)
  return file_.GetNoArena();
}
inline void s3object::set_file(const ::std::string& value) {
  
  file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.s3object.file)
}
#if LANG_CXX11
inline void s3object::set_file(::std::string&& value) {
  
  file_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.s3object.file)
}
#endif
inline void s3object::set_file(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.s3object.file)
}
inline void s3object::set_file(const char* value, size_t size) {
  
  file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.s3object.file)
}
inline ::std::string* s3object::mutable_file() {
  
  // @@protoc_insertion_point(field_mutable:s3service.s3object.file)
  return file_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* s3object::release_file() {
  // @@protoc_insertion_point(field_release:s3service.s3object.file)
  
  return file_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void s3object::set_allocated_file(::std::string* file) {
  if (file != NULL) {
    
  } else {
    
  }
  file_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file);
  // @@protoc_insertion_point(field_set_allocated:s3service.s3object.file)
}

// repeated string multiPartList = 11;
inline int s3object::multipartlist_size() const {
  return multipartlist_.size();
}
inline void s3object::clear_multipartlist() {
  multipartlist_.Clear();
}
inline const ::std::string& s3object::multipartlist(int index) const {
  // @@protoc_insertion_point(field_get:s3service.s3object.multiPartList)
  return multipartlist_.Get(index);
}
inline ::std::string* s3object::mutable_multipartlist(int index) {
  // @@protoc_insertion_point(field_mutable:s3service.s3object.multiPartList)
  return multipartlist_.Mutable(index);
}
inline void s3object::set_multipartlist(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:s3service.s3object.multiPartList)
  multipartlist_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void s3object::set_multipartlist(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:s3service.s3object.multiPartList)
  multipartlist_.Mutable(index)->assign(std::move(value));
}
#endif
inline void s3object::set_multipartlist(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  multipartlist_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:s3service.s3object.multiPartList)
}
inline void s3object::set_multipartlist(int index, const char* value, size_t size) {
  multipartlist_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:s3service.s3object.multiPartList)
}
inline ::std::string* s3object::add_multipartlist() {
  // @@protoc_insertion_point(field_add_mutable:s3service.s3object.multiPartList)
  return multipartlist_.Add();
}
inline void s3object::add_multipartlist(const ::std::string& value) {
  multipartlist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:s3service.s3object.multiPartList)
}
#if LANG_CXX11
inline void s3object::add_multipartlist(::std::string&& value) {
  multipartlist_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:s3service.s3object.multiPartList)
}
#endif
inline void s3object::add_multipartlist(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  multipartlist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:s3service.s3object.multiPartList)
}
inline void s3object::add_multipartlist(const char* value, size_t size) {
  multipartlist_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:s3service.s3object.multiPartList)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
s3object::multipartlist() const {
  // @@protoc_insertion_point(field_list:s3service.s3object.multiPartList)
  return multipartlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
s3object::mutable_multipartlist() {
  // @@protoc_insertion_point(field_mutable_list:s3service.s3object.multiPartList)
  return &multipartlist_;
}

// string multiPartNo = 12;
inline void s3object::clear_multipartno() {
  multipartno_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& s3object::multipartno() const {
  // @@protoc_insertion_point(field_get:s3service.s3object.multiPartNo)
  return multipartno_.GetNoArena();
}
inline void s3object::set_multipartno(const ::std::string& value) {
  
  multipartno_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.s3object.multiPartNo)
}
#if LANG_CXX11
inline void s3object::set_multipartno(::std::string&& value) {
  
  multipartno_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.s3object.multiPartNo)
}
#endif
inline void s3object::set_multipartno(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  multipartno_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.s3object.multiPartNo)
}
inline void s3object::set_multipartno(const char* value, size_t size) {
  
  multipartno_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.s3object.multiPartNo)
}
inline ::std::string* s3object::mutable_multipartno() {
  
  // @@protoc_insertion_point(field_mutable:s3service.s3object.multiPartNo)
  return multipartno_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* s3object::release_multipartno() {
  // @@protoc_insertion_point(field_release:s3service.s3object.multiPartNo)
  
  return multipartno_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void s3object::set_allocated_multipartno(::std::string* multipartno) {
  if (multipartno != NULL) {
    
  } else {
    
  }
  multipartno_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), multipartno);
  // @@protoc_insertion_point(field_set_allocated:s3service.s3object.multiPartNo)
}

// string multiPartUniqueId = 13;
inline void s3object::clear_multipartuniqueid() {
  multipartuniqueid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& s3object::multipartuniqueid() const {
  // @@protoc_insertion_point(field_get:s3service.s3object.multiPartUniqueId)
  return multipartuniqueid_.GetNoArena();
}
inline void s3object::set_multipartuniqueid(const ::std::string& value) {
  
  multipartuniqueid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.s3object.multiPartUniqueId)
}
#if LANG_CXX11
inline void s3object::set_multipartuniqueid(::std::string&& value) {
  
  multipartuniqueid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.s3object.multiPartUniqueId)
}
#endif
inline void s3object::set_multipartuniqueid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  multipartuniqueid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.s3object.multiPartUniqueId)
}
inline void s3object::set_multipartuniqueid(const char* value, size_t size) {
  
  multipartuniqueid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.s3object.multiPartUniqueId)
}
inline ::std::string* s3object::mutable_multipartuniqueid() {
  
  // @@protoc_insertion_point(field_mutable:s3service.s3object.multiPartUniqueId)
  return multipartuniqueid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* s3object::release_multipartuniqueid() {
  // @@protoc_insertion_point(field_release:s3service.s3object.multiPartUniqueId)
  
  return multipartuniqueid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void s3object::set_allocated_multipartuniqueid(::std::string* multipartuniqueid) {
  if (multipartuniqueid != NULL) {
    
  } else {
    
  }
  multipartuniqueid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), multipartuniqueid);
  // @@protoc_insertion_point(field_set_allocated:s3service.s3object.multiPartUniqueId)
}

// bool locking = 22;
inline void s3object::clear_locking() {
  locking_ = false;
}
inline bool s3object::locking() const {
  // @@protoc_insertion_point(field_get:s3service.s3object.locking)
  return locking_;
}
inline void s3object::set_locking(bool value) {
  
  locking_ = value;
  // @@protoc_insertion_point(field_set:s3service.s3object.locking)
}

// string retention_duration = 23;
inline void s3object::clear_retention_duration() {
  retention_duration_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& s3object::retention_duration() const {
  // @@protoc_insertion_point(field_get:s3service.s3object.retention_duration)
  return retention_duration_.GetNoArena();
}
inline void s3object::set_retention_duration(const ::std::string& value) {
  
  retention_duration_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.s3object.retention_duration)
}
#if LANG_CXX11
inline void s3object::set_retention_duration(::std::string&& value) {
  
  retention_duration_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.s3object.retention_duration)
}
#endif
inline void s3object::set_retention_duration(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  retention_duration_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.s3object.retention_duration)
}
inline void s3object::set_retention_duration(const char* value, size_t size) {
  
  retention_duration_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.s3object.retention_duration)
}
inline ::std::string* s3object::mutable_retention_duration() {
  
  // @@protoc_insertion_point(field_mutable:s3service.s3object.retention_duration)
  return retention_duration_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* s3object::release_retention_duration() {
  // @@protoc_insertion_point(field_release:s3service.s3object.retention_duration)
  
  return retention_duration_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void s3object::set_allocated_retention_duration(::std::string* retention_duration) {
  if (retention_duration != NULL) {
    
  } else {
    
  }
  retention_duration_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), retention_duration);
  // @@protoc_insertion_point(field_set_allocated:s3service.s3object.retention_duration)
}

// -------------------------------------------------------------------

// S3server

// .s3service.S3server.serveroperation serverOp = 1;
inline void S3server::clear_serverop() {
  serverop_ = 0;
}
inline ::s3service::S3server_serveroperation S3server::serverop() const {
  // @@protoc_insertion_point(field_get:s3service.S3server.serverOp)
  return static_cast< ::s3service::S3server_serveroperation >(serverop_);
}
inline void S3server::set_serverop(::s3service::S3server_serveroperation value) {
  
  serverop_ = value;
  // @@protoc_insertion_point(field_set:s3service.S3server.serverOp)
}

// repeated .s3service.s3authorization auth = 2;
inline int S3server::auth_size() const {
  return auth_.size();
}
inline void S3server::clear_auth() {
  auth_.Clear();
}
inline ::s3service::s3authorization* S3server::mutable_auth(int index) {
  // @@protoc_insertion_point(field_mutable:s3service.S3server.auth)
  return auth_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::s3service::s3authorization >*
S3server::mutable_auth() {
  // @@protoc_insertion_point(field_mutable_list:s3service.S3server.auth)
  return &auth_;
}
inline const ::s3service::s3authorization& S3server::auth(int index) const {
  // @@protoc_insertion_point(field_get:s3service.S3server.auth)
  return auth_.Get(index);
}
inline ::s3service::s3authorization* S3server::add_auth() {
  // @@protoc_insertion_point(field_add:s3service.S3server.auth)
  return auth_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::s3service::s3authorization >&
S3server::auth() const {
  // @@protoc_insertion_point(field_list:s3service.S3server.auth)
  return auth_;
}

// repeated .s3service.errorDetails errorInfo = 3;
inline int S3server::errorinfo_size() const {
  return errorinfo_.size();
}
inline void S3server::clear_errorinfo() {
  errorinfo_.Clear();
}
inline ::s3service::errorDetails* S3server::mutable_errorinfo(int index) {
  // @@protoc_insertion_point(field_mutable:s3service.S3server.errorInfo)
  return errorinfo_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::s3service::errorDetails >*
S3server::mutable_errorinfo() {
  // @@protoc_insertion_point(field_mutable_list:s3service.S3server.errorInfo)
  return &errorinfo_;
}
inline const ::s3service::errorDetails& S3server::errorinfo(int index) const {
  // @@protoc_insertion_point(field_get:s3service.S3server.errorInfo)
  return errorinfo_.Get(index);
}
inline ::s3service::errorDetails* S3server::add_errorinfo() {
  // @@protoc_insertion_point(field_add:s3service.S3server.errorInfo)
  return errorinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::s3service::errorDetails >&
S3server::errorinfo() const {
  // @@protoc_insertion_point(field_list:s3service.S3server.errorInfo)
  return errorinfo_;
}

// string serverMessage = 4;
inline void S3server::clear_servermessage() {
  servermessage_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& S3server::servermessage() const {
  // @@protoc_insertion_point(field_get:s3service.S3server.serverMessage)
  return servermessage_.GetNoArena();
}
inline void S3server::set_servermessage(const ::std::string& value) {
  
  servermessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.S3server.serverMessage)
}
#if LANG_CXX11
inline void S3server::set_servermessage(::std::string&& value) {
  
  servermessage_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.S3server.serverMessage)
}
#endif
inline void S3server::set_servermessage(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  servermessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.S3server.serverMessage)
}
inline void S3server::set_servermessage(const char* value, size_t size) {
  
  servermessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.S3server.serverMessage)
}
inline ::std::string* S3server::mutable_servermessage() {
  
  // @@protoc_insertion_point(field_mutable:s3service.S3server.serverMessage)
  return servermessage_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* S3server::release_servermessage() {
  // @@protoc_insertion_point(field_release:s3service.S3server.serverMessage)
  
  return servermessage_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void S3server::set_allocated_servermessage(::std::string* servermessage) {
  if (servermessage != NULL) {
    
  } else {
    
  }
  servermessage_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), servermessage);
  // @@protoc_insertion_point(field_set_allocated:s3service.S3server.serverMessage)
}

// -------------------------------------------------------------------

// serviceRequestResponse

// .s3service.serviceRequestResponse.serviceEntity entityType = 1;
inline void serviceRequestResponse::clear_entitytype() {
  entitytype_ = 0;
}
inline ::s3service::serviceRequestResponse_serviceEntity serviceRequestResponse::entitytype() const {
  // @@protoc_insertion_point(field_get:s3service.serviceRequestResponse.entityType)
  return static_cast< ::s3service::serviceRequestResponse_serviceEntity >(entitytype_);
}
inline void serviceRequestResponse::set_entitytype(::s3service::serviceRequestResponse_serviceEntity value) {
  
  entitytype_ = value;
  // @@protoc_insertion_point(field_set:s3service.serviceRequestResponse.entityType)
}

// string requestId = 2;
inline void serviceRequestResponse::clear_requestid() {
  requestid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& serviceRequestResponse::requestid() const {
  // @@protoc_insertion_point(field_get:s3service.serviceRequestResponse.requestId)
  return requestid_.GetNoArena();
}
inline void serviceRequestResponse::set_requestid(const ::std::string& value) {
  
  requestid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:s3service.serviceRequestResponse.requestId)
}
#if LANG_CXX11
inline void serviceRequestResponse::set_requestid(::std::string&& value) {
  
  requestid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:s3service.serviceRequestResponse.requestId)
}
#endif
inline void serviceRequestResponse::set_requestid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  requestid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:s3service.serviceRequestResponse.requestId)
}
inline void serviceRequestResponse::set_requestid(const char* value, size_t size) {
  
  requestid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:s3service.serviceRequestResponse.requestId)
}
inline ::std::string* serviceRequestResponse::mutable_requestid() {
  
  // @@protoc_insertion_point(field_mutable:s3service.serviceRequestResponse.requestId)
  return requestid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* serviceRequestResponse::release_requestid() {
  // @@protoc_insertion_point(field_release:s3service.serviceRequestResponse.requestId)
  
  return requestid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void serviceRequestResponse::set_allocated_requestid(::std::string* requestid) {
  if (requestid != NULL) {
    
  } else {
    
  }
  requestid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), requestid);
  // @@protoc_insertion_point(field_set_allocated:s3service.serviceRequestResponse.requestId)
}

// repeated .s3service.s3user user = 3;
inline int serviceRequestResponse::user_size() const {
  return user_.size();
}
inline void serviceRequestResponse::clear_user() {
  user_.Clear();
}
inline ::s3service::s3user* serviceRequestResponse::mutable_user(int index) {
  // @@protoc_insertion_point(field_mutable:s3service.serviceRequestResponse.user)
  return user_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::s3service::s3user >*
serviceRequestResponse::mutable_user() {
  // @@protoc_insertion_point(field_mutable_list:s3service.serviceRequestResponse.user)
  return &user_;
}
inline const ::s3service::s3user& serviceRequestResponse::user(int index) const {
  // @@protoc_insertion_point(field_get:s3service.serviceRequestResponse.user)
  return user_.Get(index);
}
inline ::s3service::s3user* serviceRequestResponse::add_user() {
  // @@protoc_insertion_point(field_add:s3service.serviceRequestResponse.user)
  return user_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::s3service::s3user >&
serviceRequestResponse::user() const {
  // @@protoc_insertion_point(field_list:s3service.serviceRequestResponse.user)
  return user_;
}

// repeated .s3service.s3account account = 4;
inline int serviceRequestResponse::account_size() const {
  return account_.size();
}
inline void serviceRequestResponse::clear_account() {
  account_.Clear();
}
inline ::s3service::s3account* serviceRequestResponse::mutable_account(int index) {
  // @@protoc_insertion_point(field_mutable:s3service.serviceRequestResponse.account)
  return account_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::s3service::s3account >*
serviceRequestResponse::mutable_account() {
  // @@protoc_insertion_point(field_mutable_list:s3service.serviceRequestResponse.account)
  return &account_;
}
inline const ::s3service::s3account& serviceRequestResponse::account(int index) const {
  // @@protoc_insertion_point(field_get:s3service.serviceRequestResponse.account)
  return account_.Get(index);
}
inline ::s3service::s3account* serviceRequestResponse::add_account() {
  // @@protoc_insertion_point(field_add:s3service.serviceRequestResponse.account)
  return account_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::s3service::s3account >&
serviceRequestResponse::account() const {
  // @@protoc_insertion_point(field_list:s3service.serviceRequestResponse.account)
  return account_;
}

// repeated .s3service.s3bucket bucket = 5;
inline int serviceRequestResponse::bucket_size() const {
  return bucket_.size();
}
inline void serviceRequestResponse::clear_bucket() {
  bucket_.Clear();
}
inline ::s3service::s3bucket* serviceRequestResponse::mutable_bucket(int index) {
  // @@protoc_insertion_point(field_mutable:s3service.serviceRequestResponse.bucket)
  return bucket_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::s3service::s3bucket >*
serviceRequestResponse::mutable_bucket() {
  // @@protoc_insertion_point(field_mutable_list:s3service.serviceRequestResponse.bucket)
  return &bucket_;
}
inline const ::s3service::s3bucket& serviceRequestResponse::bucket(int index) const {
  // @@protoc_insertion_point(field_get:s3service.serviceRequestResponse.bucket)
  return bucket_.Get(index);
}
inline ::s3service::s3bucket* serviceRequestResponse::add_bucket() {
  // @@protoc_insertion_point(field_add:s3service.serviceRequestResponse.bucket)
  return bucket_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::s3service::s3bucket >&
serviceRequestResponse::bucket() const {
  // @@protoc_insertion_point(field_list:s3service.serviceRequestResponse.bucket)
  return bucket_;
}

// repeated .s3service.s3object object = 6;
inline int serviceRequestResponse::object_size() const {
  return object_.size();
}
inline void serviceRequestResponse::clear_object() {
  object_.Clear();
}
inline ::s3service::s3object* serviceRequestResponse::mutable_object(int index) {
  // @@protoc_insertion_point(field_mutable:s3service.serviceRequestResponse.object)
  return object_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::s3service::s3object >*
serviceRequestResponse::mutable_object() {
  // @@protoc_insertion_point(field_mutable_list:s3service.serviceRequestResponse.object)
  return &object_;
}
inline const ::s3service::s3object& serviceRequestResponse::object(int index) const {
  // @@protoc_insertion_point(field_get:s3service.serviceRequestResponse.object)
  return object_.Get(index);
}
inline ::s3service::s3object* serviceRequestResponse::add_object() {
  // @@protoc_insertion_point(field_add:s3service.serviceRequestResponse.object)
  return object_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::s3service::s3object >&
serviceRequestResponse::object() const {
  // @@protoc_insertion_point(field_list:s3service.serviceRequestResponse.object)
  return object_;
}

// repeated .s3service.s3accesskey accesskey = 7;
inline int serviceRequestResponse::accesskey_size() const {
  return accesskey_.size();
}
inline void serviceRequestResponse::clear_accesskey() {
  accesskey_.Clear();
}
inline ::s3service::s3accesskey* serviceRequestResponse::mutable_accesskey(int index) {
  // @@protoc_insertion_point(field_mutable:s3service.serviceRequestResponse.accesskey)
  return accesskey_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::s3service::s3accesskey >*
serviceRequestResponse::mutable_accesskey() {
  // @@protoc_insertion_point(field_mutable_list:s3service.serviceRequestResponse.accesskey)
  return &accesskey_;
}
inline const ::s3service::s3accesskey& serviceRequestResponse::accesskey(int index) const {
  // @@protoc_insertion_point(field_get:s3service.serviceRequestResponse.accesskey)
  return accesskey_.Get(index);
}
inline ::s3service::s3accesskey* serviceRequestResponse::add_accesskey() {
  // @@protoc_insertion_point(field_add:s3service.serviceRequestResponse.accesskey)
  return accesskey_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::s3service::s3accesskey >&
serviceRequestResponse::accesskey() const {
  // @@protoc_insertion_point(field_list:s3service.serviceRequestResponse.accesskey)
  return accesskey_;
}

// repeated .s3service.S3server server = 8;
inline int serviceRequestResponse::server_size() const {
  return server_.size();
}
inline void serviceRequestResponse::clear_server() {
  server_.Clear();
}
inline ::s3service::S3server* serviceRequestResponse::mutable_server(int index) {
  // @@protoc_insertion_point(field_mutable:s3service.serviceRequestResponse.server)
  return server_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::s3service::S3server >*
serviceRequestResponse::mutable_server() {
  // @@protoc_insertion_point(field_mutable_list:s3service.serviceRequestResponse.server)
  return &server_;
}
inline const ::s3service::S3server& serviceRequestResponse::server(int index) const {
  // @@protoc_insertion_point(field_get:s3service.serviceRequestResponse.server)
  return server_.Get(index);
}
inline ::s3service::S3server* serviceRequestResponse::add_server() {
  // @@protoc_insertion_point(field_add:s3service.serviceRequestResponse.server)
  return server_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::s3service::S3server >&
serviceRequestResponse::server() const {
  // @@protoc_insertion_point(field_list:s3service.serviceRequestResponse.server)
  return server_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace s3service

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::s3service::s3accesskey_accesskeyOperation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::s3service::s3accesskey_accesskeyOperation>() {
  return ::s3service::s3accesskey_accesskeyOperation_descriptor();
}
template <> struct is_proto_enum< ::s3service::s3account_accountOperation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::s3service::s3account_accountOperation>() {
  return ::s3service::s3account_accountOperation_descriptor();
}
template <> struct is_proto_enum< ::s3service::s3user_userOperation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::s3service::s3user_userOperation>() {
  return ::s3service::s3user_userOperation_descriptor();
}
template <> struct is_proto_enum< ::s3service::s3bucket_bucketOperation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::s3service::s3bucket_bucketOperation>() {
  return ::s3service::s3bucket_bucketOperation_descriptor();
}
template <> struct is_proto_enum< ::s3service::s3object_objectOperation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::s3service::s3object_objectOperation>() {
  return ::s3service::s3object_objectOperation_descriptor();
}
template <> struct is_proto_enum< ::s3service::S3server_serveroperation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::s3service::S3server_serveroperation>() {
  return ::s3service::S3server_serveroperation_descriptor();
}
template <> struct is_proto_enum< ::s3service::serviceRequestResponse_serviceEntity> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::s3service::serviceRequestResponse_serviceEntity>() {
  return ::s3service::serviceRequestResponse_serviceEntity_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_s3service_2eproto
